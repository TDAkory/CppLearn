# 可执行文件的装载和进程

## 进程虚拟地址空间

每个程序被运行起来，都有自己独立的虚拟地址空间，其大小由计算机的硬件平台决定：CPU位数-->寻址空间的大小-->地址空间的理论上限。

以32位为例，虚拟地址空间大小为4GB，当程序并不能任意使用。默认的，高地址的1GB 0xC0000000 ~ 0xFFFFFFFF 是操作系统分配给内核的，剩下的3GB，原则上是分配给进程使用的。

**PAE（Physical Address Extension）**：32位CPU下，程序能否使用超过4GB内存？如果指虚拟地址空间，不能，因为32位CPU只能使用32为指针，寻址范围被限定；如果指计算机的内存空间，可以，Intel自1995采用了36位的物理地址，可以访问64GB物理内存。得益于页映射方式的修改，可以访问到更多的物理内存，即PAE。

扩展的物理地址空间，应用程序是感知不到的。那么应当如何使用呢？一个常见的方式是操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来，应用程序可以根据需要来选择申请和映射。比如0x10000000~0x20000000这一段256MB作为窗口，程序可以从高于4GB的物理地址空间中申请多个大小为256MB的块，按序映射到虚拟地址空间上来使用。Windows下，这种方式叫做AWE（Address Windowing Extensions），Linux下，通过mmap()实现。

## 装载的方式

程序执行时所需要的指令和数据必须在内存中才能正常运行，最简单的办法就是全部装入内存。

矛盾点在于内存可能不足。后来研究发现，可以利用局部性原理，将程序中最常用的部分驻留在内存中，将不太常用的数据房子啊磁盘上，按需加载，这就是动态装载的基本原理：覆盖装入（Overlay）、页映射（Paging）

### 覆盖装入

把挖掘内存迁离的任务交给程序员，在编写时将程序分隔成若干块，然后编写一个辅助代码来管理这些模块应该何时加载、何时被替换掉，被称为Overlay Manager。在复杂程序涉及多模块时，程序员必须手工将模块按照它们之间的调用依赖关系组织成树状结构。（要求： 每个调用路径上的模块必须同时在内存中、不允许跨树调用）。

执行效率和开发效率低，仅在某些受限场景下保留，大部分场景已经弃用。

### 页映射

> TODO 补充虚拟内存介绍

是虚拟存储机制的一部分。

将内存和所有磁盘中的数据和指令按照 页 为单位划分成若干个页，后续装载和操作的单位都是页。

## 从操作系统角度看可执行文件的装载

> 从操作系统视角，一个进程最关键的特征是拥有独立的虚拟地址空间

下面描述创建一个进程，然后装载相应的可执行文件并执行的过程

1. **创建一个独立的虚拟地址空间**：一个虚拟空间由一组页映射函数将虚拟空间的各个页映射到相应的物理空间，因此创建虚拟空间实质上并不是创建空间，二是创建映射函数所需要的相应数据结构。
2. **读取可执行文件头，建立虚拟地址空间与可执行文件的映射关系**；上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步是虚拟空间与可执行文件的映射关系。
3. **将CPU的指令寄存器设置成可执行文件的入口地址，启动执行**：涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换等

> 由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）

这种映射关系只是保存在操作系统的一个数据结构，Linux中奖进程虚拟克难攻坚中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。比如，操作系统创建进程后，会在进程相应的数据结构中设置一个`.text`段的`VMA`，它在虚拟空间中的地址为`0x08048000~0x08049000`，对应`ELF`文件中偏移为`0`的`.text`，它的属性是只读，etc

**页错误**：上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。 假设在上面的例子中，程序的入又地址为Ox08048000，即刚好是.text 段的起始地址。当CPU开始打算执行这个地址的指令时，发现页面0x08048000 ~0x08049000是个空页面，于是它就认为这是一个页错误 (Page Fault )。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。这时候我们前面提到的装载过程的第二步建立的数据结构起到了很关键的作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理贞之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。

随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来 满足进程执行的需求。

> 操作系统虚拟内存管理 

## 进程虚拟空间分布

实际产生的可执行文件包含很多段，而操作系统映射时必须以页长度为单位，这就会带来内存的浪费。

实质上，操作系统并不关心可执行文件各个段所包含的实际内容，它只关心一些与装载相关的内容：最主要的是段的访问权限（可读、可写、可执行）。同时，在ELF文件中，权限仅有为数不多的几个组合：

* 以代码段为代表的可读可执行
* 以数据段和BSS段为代码的可读可写
* 以只读数据段代表的只读

因此，对于相同权限的段，可以把它们合并到一起当做一个段进行映射。ELF引入一个概念叫做Segment，一个Segment包含一个或多个属性类似的Section。