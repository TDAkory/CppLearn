# System call & API

## Linux 系统调用

x86系统下，通过0x80中断完成，使用通用寄存器来传递参数。EAX表示系统调用接口号；返回时，EAX存储调用结果。

系统调用的一些弊端：

* 使用不方便
* 跨平台不兼容

运行库提供中间层来屏蔽差异性。但同时也是为了兼容，运行库只能提供各平台功能的交集。

## 系统调用原理

### 1. 特权级
特权级是计算机系统中用于控制硬件资源访问权限和程序执行权限的一种机制，主要用于保护系统安全和稳定性。它通常将系统划分为不同的权限级别，不同级别的程序具有不同的访问权限。

#### （1）特权级的分类
特权级的具体划分因操作系统和硬件架构而异，但常见的有以下几种：
- **内核态（高特权级）**：内核态是操作系统的核心运行模式，具有最高权限。操作系统内核、设备驱动程序等运行在内核态，可以访问所有硬件资源和系统内存，执行所有指令。
- **用户态（低特权级）**：用户态是普通应用程序的运行模式，权限较低。用户态程序只能访问受限的资源，不能直接访问硬件设备或执行特权指令。如果需要访问硬件资源或执行特权操作，必须通过系统调用请求内核态程序来完成。

#### （2）特权级的作用
- **保护系统资源**：防止用户态程序直接访问硬件资源或修改系统关键数据，避免因错误操作导致系统崩溃。
- **隔离程序运行**：用户态程序之间相互隔离，一个程序的错误不会影响其他程序或系统内核。
- **提高系统安全性**：防止恶意程序直接访问系统核心，减少安全风险。

### 2. 中断
中断是计算机系统中一种重要的机制，它允许硬件设备或软件程序在特定条件下中断当前的程序执行流程，请求处理器执行特定的中断处理程序。中断机制使得计算机能够及时响应外部事件或内部异常，提高系统的效率和响应能力。

#### （1）中断的分类
- **硬件中断**：由外部硬件设备触发的中断。例如：
  - **I/O中断**：当硬件设备完成输入/输出操作后，如磁盘读写完成、键盘输入等，会向处理器发送中断信号，请求处理器处理。
  - **时钟中断**：由系统时钟定时触发的中断，用于实现任务调度、时间管理等功能。
- **软件中断**：由软件程序主动触发的中断。例如：
  - **系统调用**：用户态程序通过软件中断请求操作系统内核提供服务，如文件操作、进程控制等。
  - **异常处理**：程序运行时发生错误（如除以零、非法内存访问等）会触发异常中断，操作系统会根据异常类型执行相应的处理程序。

#### （2）中断的处理过程
1. **中断请求**：硬件设备或软件程序发出中断信号。
2. **中断响应**：处理器检测到中断信号后，暂停当前程序的执行，保存当前程序的上下文信息（如程序计数器、寄存器状态等）。
3. **中断处理**：处理器跳转到中断处理程序，执行相应的处理逻辑。
4. **中断返回**：中断处理程序执行完毕后，恢复被中断程序的上下文信息，继续执行原程序。

#### （3）中断的作用
- **提高系统效率**：允许处理器在执行当前任务时，能够及时响应外部事件，避免因等待设备操作而浪费时间。
- **实现多任务调度**：通过时钟中断，操作系统可以定期切换进程，实现多任务并发运行。
- **处理异常情况**：当程序运行出错时，中断机制可以及时捕获异常并进行处理，防止程序崩溃导致系统不稳定。

**中断向量表（Interrupt Vector Table，IVT）**是计算机系统中用于管理和响应中断的重要数据结构，它存储了中断服务程序（ISR）的入口地址。表空间是有限的额，操作系统不舍得用一个中断号对应一个系统调用。比如在linux中，系统调用号由eax传入，系统调用中断号是 0x80 ，以此来触发系统调用。

### linux的经典系统调用实现

在 Linux 系统中，系统调用是用户态程序与内核态交互的重要方式，用于请求操作系统提供的服务。基于 `int` 指令的系统调用实现是 Linux 在 x86 架构早期的经典实现方式。随着技术的发展，现代 Linux 系统更多地使用更高效的机制（如 `syscall` 指令），但基于 `int` 的实现仍然是理解系统调用机制的重要基础。

* 用户态程序通过 `int 0x80` 指令请求系统调用。在执行这条指令之前，程序需要将系统调用号（syscall number）放入 `eax` 寄存器，并将系统调用的参数放入其他寄存器（通常是 `ebx`、`ecx`、`edx` 等）。

* 执行 `int 0x80` 指令后，处理器会触发中断，从中断向量表中找到对应的中断处理程序入口地址。对于 `int 0x80`，中断向量表中存储的是 Linux 内核的系统调用处理程序入口地址。

* 处理器切换到内核态，执行内核中的系统调用处理程序。内核根据 `eax` 寄存器中的系统调用号，调用对应的系统调用处理函数。系统调用的参数通过寄存器传递给内核。

* 系统调用处理完成后，内核将返回值放入 `eax` 寄存器，并通过 `iret` 指令返回用户态。用户态程序可以从 `eax` 寄存器中获取系统调用的返回值。

```c
#include <unistd.h>
#include <sys/syscall.h>

int main() {
    const char *msg = "Hello, World!\n";
    syscall(SYS_write, 1, msg, 14); // 使用 syscall 宏调用 write 系统调用
    return 0;
}
```

如果直接使用汇编语言，可以更直观地看到 `int 0x80` 的使用：

```assembly
section .data
    msg db "Hello, World!", 0xA  ; 字符串和换行符
    len equ $ - msg              ; 字符串长度

section .text
    global _start

_start:
    mov eax, 4                   ; 系统调用号：write
    mov ebx, 1                   ; 文件描述符：stdout
    mov ecx, msg                 ; 字符串地址
    mov edx, len                 ; 字符串长度
    int 0x80                     ; 触发中断，请求系统调用

    mov eax, 1                   ; 系统调用号：exit
    xor ebx, ebx                 ; 返回值：0
    int 0x80                     ; 触发中断，请求系统调用
```

现代 Linux 系统更多地使用 `syscall` 指令来实现系统调用。`syscall` 指令比 `int 0x80` 更高效，因为它直接切换到内核态，而不需要经过中断处理程序。在 x86-64 架构中，系统调用号和参数通过以下寄存器传递：

- **`rax`**：系统调用号。
- **`rdi`**：第一个参数。
- **`rsi`**：第二个参数。
- **`rdx`**：第三个参数。
- **`r10`**：第四个参数。
- **`r8`**：第五个参数。
- **`r9`**：第六个参数。

当中断发生时，处理器会自动执行以下操作来保存上下文信息，并切换到中断处理程序：

1. **保存程序计数器（PC）**：处理器将当前程序的指令指针（IP）压入栈中，记录中断发生时程序执行到的位置。
2. **保存标志寄存器（FLAGS）**：处理器将标志寄存器的值压入栈中，保存程序的状态标志。
3. **保存寄存器状态**：根据中断类型，处理器可能还会将其他寄存器的值压入栈中。例如，在某些复杂的中断处理中，通用寄存器（如 `AX`、`BX`、`CX` 等）的值也会被保存。

`IRET` 指令会从栈中恢复 `EIP` 和 `EFLAGS` 的值，并返回到原程序的执行位置：

- **栈空间分配**：中断处理程序需要有足够的栈空间来保存上下文信息。如果栈空间不足，可能会导致栈溢出，进而引发系统崩溃。
- **中断嵌套**：在某些情况下，中断处理程序可能会被更高优先级的中断打断。处理器会再次切换栈，保存新的上下文信息。因此，中断处理程序的设计需要考虑嵌套中断的情况。
- **上下文恢复的完整性**：中断返回时，必须确保所有寄存器状态和程序计数器的值都被正确恢复，否则原程序可能会出现异常行为。

### linux新型系统调用机制

```shell
$ ldd /bin/ls
	linux-vdso.so.1 (0x00007fffbfdf2000)
	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007efd1f175000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007efd1efb5000)
	libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007efd1ef41000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007efd1ef3c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007efd1f3cd000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007efd1ef1b000)
```

`linux-gate.so.1` 即`linux-vdso.so.1` 是 Linux 系统中一个特殊的虚拟共享库(Virtual Dynamic Shared Library)，它在用户空间和内核空间之间起到了桥梁的作用，主要用于加速系统调用的执行。总是被加载在 0xffffe000 地址上，这个虚拟文件的大小是 4096 字节，因为其在任何进程中的位置都相同，可以用如下方式导出：

```shell
dd if=/proc/self/mem of=linux-gate.sdo bs=4096 skip=${offset in decimal} count=1
```

下面是通过运行一个ping程序，然后`sudo dd if=/proc/1215801/mem of=linux-gate.dso bs=4096 skip=34357411259 count=1`，得到的`linux-gate.sdo`:

```shell
~> objdump -T linux-gate.dso

linux-gate.dso:     file format elf64-x86-64

DYNAMIC SYMBOL TABLE:
0000000000000900  w   DF .text	00000000000000a8  LINUX_2.6   clock_gettime
0000000000000860 g    DF .text	0000000000000087  LINUX_2.6   __vdso_gettimeofday
00000000000009b0  w   DF .text	0000000000000005  LINUX_2.6   clock_getres
00000000000009b0 g    DF .text	0000000000000005  LINUX_2.6   __vdso_clock_getres
0000000000000860  w   DF .text	0000000000000087  LINUX_2.6   gettimeofday
00000000000008f0 g    DF .text	0000000000000010  LINUX_2.6   __vdso_time
00000000000008f0  w   DF .text	0000000000000010  LINUX_2.6   time
0000000000000900 g    DF .text	00000000000000a8  LINUX_2.6   __vdso_clock_gettime
0000000000000000 g    DO *ABS*	0000000000000000  LINUX_2.6   LINUX_2.6
00000000000009c0 g    DF .text	000000000000002a  LINUX_2.6   __vdso_getcpu
00000000000009c0  w   DF .text	000000000000002a  LINUX_2.6   getcpu
```

看起来与书中描述似乎不一致，这是因为：在较新的 Linux 内核版本中，`__kernel_vsyscall` 的使用方式可能发生了变化。例如，某些系统调用（如 `gettimeofday`、`time` 和 `getcpu`）可能通过 `vDSO` 机制实现，而其他系统调用则直接使用 `syscall` 指令。

当用户空间的应用程序发起系统调用时，`linux-gate.so.1` 负责将调用请求传递给内核，并将执行结果返回给用户空间。

在 x86 架构中，`linux-gate.so.1` 提供了虚拟系统调用的支持，例如 `__kernel_vsyscall`、`__kernel_sigreturn` 和 `__kernel_rt_sigreturn` 等函数的入口点。

`linux-gate.so.1` 被映射到一个固定的内存地址（例如在 32 位系统中通常是 `0xffffe000`），这使得所有进程都能以相同的方式访问它。
