# Linux共享库的组织

## 共享库版本

### 兼容性

兼容更新 & 不兼容更新

ABI兼容性：函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等规则

一些兼容和不兼容的变更类型：

- 兼容：向共享库中添加导出符号
- 不兼容：删除共享库中原有的导出符号
- 不兼容：给共享库中原有的导出函数增加参数
- 不兼容：给共享库中原有的导出函数删除参数
- 不兼容：变更一个导出结构类型（被用于导出函数或全局变量）的长度、内容、成员类型
- 兼容：在不改变导出函数的语义、功能、行为、接口的前提下的变更：如修正bug，强化性能
- 不兼容：破坏了上一条的前提

通常在linux下，我们建议开发导出接口为C的共享库（因为C++的ABI兼容性约束更多）

C++ ABI兼容性保证的一些建议（完全遵守也不能保证ABI完全兼容）：

- 不在接口类中使用虚函数，一旦使用，不要随意删除、添加或在子类中添加新的实现函数，这会引起虚函数表结构变化
- 不改变勒种成员变量的位置和类型
- 不删除非内嵌的public、protected成员函数
- 不将非内嵌的成员函数改成成员函数
- 不改变成员函数的访问权限
- 不在接口中使用模板
- 最好不要使用C++作为共享库接口

### 版本命名

```shell
libname.so.x.y.z
```

* x: 主版本号 Major，不兼容更新
* y: 次版本号 Minor，增量更新，比如增加接口符号，并保持原符号不变
* z: 发布版本号 Release，bug-fix 性能改进

### SO-Name

程序如何记录？

每个共享库都有一个对应的SO-NAME，即共享库的文件名去掉次版本号和发布版本号

SO-NAME从程序视角规定了共享库的接口。在linux系统中，系统会为每个共享库在它所在的目录创建一个名为SO-NAME的软连接，指向共享库：

- 软连接会指向相对最新的产物
- 编译、链接、运行时都是用SO-NAME，不使用详细的版本号

因此共享对象的.dynamic段中保留的依赖库的名字就是SO-NAME形式的。

Linux中工具`ldconfig`，可以遍历所有默认的共享库目录，更新软连接指向最新的共享库版本；如果安装了新的共享库，该工具也会为其创建软连接

**链接名**，`-l`的参数，通常就是库名，链接器会根据其他链接参数来选择链接静态版本还是动态版本

## 符号版本

正常情况下，为了表示某个共享库中增加了一些接口，我们就把这个共享库的次版本号升高 (表示里面添加了一些东西)。但是我们需要一种更为巧妙的方法，来解决次版本号交会问题。Linux下的Glibc 从版本2.1之后开始支持一种叫做**基于符号的版本机制 (Symbol Versioning)**的方案。这个方案的基本思路是让每个导出和导入的符号都有一个相关联的版本号，它的实际做法类似于名称修饰的方法。与以往简单地将某个共享库的版本号重新命名不同(比如将libfoo.s0.1.2 升级到libfoo.so.1.3)，当我们将libfoo.s0.1.2升级至1.3时，仍然保持libfoo.so.1这个SO-NAME，但是给在1.3 这个新版中添加的那些全局符号打上一个标记，比如“VERS_1.3”。那么，如果一个共享库每一次次版本号升级，我们都能给那些在新 的次版本号中添加的全局符号打上相应的标记，就可以清楚地看到共享库中的每个符号都拥有相应的标签，比如“VERS_1.1”、“VERS_1.2”、“VERS_1.3"。

Linux系统下共享库的符号版本机制并没有被广泛使用，主要的适用对象是Glibc软件包中提供的20多个共享库。

GCC支持使用`.symver`来定义符号的版本，如下示例把 add 指定为符号标签 VERS_1.1

```c
asm(".symver add, add@VERS_1.1");

int add(int a, int b) {
    return a + b;
}
```

GCC同时还支持多个版本的同一个符号存在于一个共享库中，即在链接层面提供了某种形式的符号重载机制

```c
asm(".symver old_printf, printf@VERS_1.1");
asm(".symver new_printf, printf@VERS_1.2");

int old_printf() {
    ...
}

int new_printf() {
    ...
}
```

使用符号脚本作为链接参数，来控制共享库中的符号版本

```shell
gcc -shared -fPIC lib.c -Xlinker --version-script lib.ver -o lib.so
```

```c
// lib.ver
VERS_1.2 {
    global:
        foo;
    local:
        *;
};
```

## 共享库系统路径

> FHS: File Hierarchy Standard. 规定了一个系统中的系统文件应该如何存放

FHS定义了系统中主要有两个存放共享库的位置：

1. `/lib`：系统关键和基础的共享库，比如动态链接器，C语言运行库、数学库等，对应的可执行通常在`/bin` `/sbin`
2. `/usr/lib`：开发时用到的共享库，也包括静态库、目标文件等
3. `/usr/local/lib`：三方库等，对应的可执行通常在`/usr/local/bin`

## 共享库查找过过程

> 动态链接的模块所以来的模块路径保存在`.dynamic`段，由 `DT_NEED` 类型的项表示

其对应的查找规则是：

如果 `DT_NEED` 保存的是绝对路径，那么动态链接器就按照这个路径去查找
如果 `DT_NEED` 保存的事相对路径，那么动态链接器会在 `/lib`、 `/usr/lib`、 `/etc/ld.so.conf`配置文件指定的目录中查找共享库

> 为了可移植性考虑，共享库的路径通常是相对路径

如果每次查找共享库都遍历目录，会非常耗时。因此linux通过 `ldconfig` 程序维护 SO-NAME，SO-NAME指向正确的共享库文件；并且 `ldconfig` 还会将 SO-NAME 收集起来，集中存放在 `/etc/ld.so.cache` 文件中，并建立一个 SO-NAME 的缓存。如果在缓存中未找到，则链接器会遍历 `/lib` `/usr/lib`两个目录，如果还是没找到，则宣告失败。

## 环境变量

### `LD_LIBRARY_PATH`

临时改变某个应用程序的共享库查找路径，不会影响系统中的其他程序。

是一个由若干个路径组成的环境变量，用冒号隔开。

1. `LD_LIBRARY_PATH` 指定的路径
2. 路径缓存文件`etc/ld.so.cache`指定的路径
3. 默认共享库目录，先 `/usr/lib` 然后`/lib`

慎用！随意修改`LD_LIBRARY_PATH`并将其导出到全局范围，可能影响其他应用程序的运行，或影响GCC编译时查找库的路径

### `LD_PRELOAD`

可以指定预先装载的一些共享库或是目标文件。被指定的文件会在动态链接器按照规则搜索共享库之前装载，优先级比`LD_LIBRARY_PATH`更高。无论最终产物是否依赖，被指定的文件都会被装载。

由于全局符号介入机制的存在，`LD_PRELOAD`里面指定的文件的全局符号会覆盖后面加载的同名的全局符号。利用这一点可以做到改写标准C库的个别函数，而不影响其他函数。

系统配置文件`/etc/ld.so.preload`作用和`LD_PRELOAD`一样。

### `LD_DEBUG`

调试功能，打开时会在链接时输出详细的信息

* LD_DEBUG=files : 文件级别的信息
* bingdings ： 输出符号绑定过程
* libs ： 显示共享库的查找过程
* versions ： 版本依赖关系
* reloc ： 显示重定位过程
* symbols ： 符号查找过程
* statistics ：显示过程中的统计信息
* all ： 以上所有
* help ：帮助信息

## 共享库的创建和安装

### 共享库的创建

`-shared` : 输出共享库
`-fPIC` : 使用地址无关代码
`-Wl` : 传入指定参数
`-Wl,-soname,my_soname` : 传入自定义的SO-NAME

### 清除符号信息

可以使用`strip`清除符号信息，在发布版本中减小文件尺寸

链接器参数：`-S`消除调试符号信息 `-s`消除所有符号信息

### 共享库的安装

通常可以复制产物到共享库默认查找路径，然后执行`ldconfig`

### 共享库构造和析构函数

在函数声明时加上`__attribute__((constructor))`，则指定该函数为共享库的构造函数，拥有这种属性的函数会在共享库加载时被执行，位于`main`之前。如果共享库是使用 dlopen 打开的，那么共享库构造函数会在 dlopen 返回之前被执行。

相对应的，共享库的析构函数用`__attribute__((destructor))`表示

需要注意的是，这种支持是GCC的扩展，需要使用系统默认的标准运行库和启动文件，即不能使用`-nostartfiles` `-nostdlib`参数。因为没有这些框架支持的话，标记函数无法按照预期被执行

同时多个标记的构造函数的执行顺序是无法保证的，可以借助优先级注记来进行控制，数值小的优先级高，析构和构造的执行顺序相反

```c
void __attribute__((constructor(5))) init_func_1(void);
void __attribute__((constructor(10))) init_func_2(void);
```

### 共享库脚本

前面描述的共享库都是动态链接的ELF共享对象文件，实际上，共享库还可以是符号一定格式的链接脚本文件。通过这种脚本，可以把几个现有的共享库铜鼓一定的方式组合起来。