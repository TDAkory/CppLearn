# Memory

## 程序内存布局

```c
// |-----------------------|   0xFFFFFFFF
// |      kernel space     |
// |-----------------------|   0xC0000000
// |        stack          |
// |-----------------------|
// |        unused         |
// |                       |
// |-----------------------|
// |   dynamic libraries   |
// |-----------------------|
// |                       |
// |                       |
// |        unused         |
// |-----------------------|
// |         heap          |
// |-----------------------|
// |  read/write sections  |
// |      (.data .bss)     |
// |-----------------------|
// |   readonly sections   |
// | (.init .rodata .text) |
// |-----------------------|   0x08048000
// |        reserved       |
// |-----------------------|   0x0
```

32位系统的典型内存分布：

1. 高位1GB位内核空间
2. 栈：维护函数调用上下文，向低地址增长
3. 动态链接库映射区：装载动态链接库
4. 堆：动态分配，向高地址增长
5. 可执行文件映像：装载可执行文件
6. 保留区：保护而禁止访问的区域的总称，通常极小地址不允许访问

## 栈和调用惯例

栈的内容：函数的返回地址和参数、临时变量、保存的上下文（调用前后需要保持不变的寄存器）

i386语义下，esp指向栈顶，ebp指向栈帧的起始位置，一种常见布局如下：

```c
// 为了便于理解，右侧寄存器在垂直方向上居中，表示指向的元素
// |-----------------------|
// |       parameters      |
// |-----------------------|
// |     return address    |
// |-----------------------| 
// |        old ebp        |    -->   ebp
// |-----------------------| 
// |    saved registers    |
// |-----------------------|
// |    local variables    |
// |-----------------------|
// |    other datas        |    -->   esp
// |-----------------------| 
```

i386的调用过程：

1. 把所有或一部分参数压栈，如果有其他参数没有入栈，使用某些特定的寄存器传递
2. 把当前指令的下一条指令的地址压栈
3. 跳转到函数体执行

i386函数调用的汇编示例：

```c
push ebp            // old ebp
mov ebp, esp        // ebp = esp
【可选】sub esp, XXX // 栈上分配临时空间
【可选】push XXX     // 保存寄存器

......


【可选】pop XXX   // 恢复寄存器
mov esp, ebp    // 恢复esp，同时回收局部变量的空间
pop ebp         // 恢复ebp
ret             // 获取返回地址，并跳转
```

**调用惯例**：函数的调用方和被调用方对于函数如何调用的明确约定，一般包括：

* 函数参数的传递顺序和方式（栈传递、压栈顺序、寄存器传递）
* 栈的维护方式（函数结束时恢复栈，由谁完成）
* 名字修饰的策略

一些常见的调用惯例如下：

> `cdecl` 是 C 语言的默认调用惯例，具有很好的可移植性；`stdcall` 常用于 Windows API 等场景，因为被调用者清理栈可以减少代码大小；`fastcall` 旨在通过寄存器传递参数提高性能；`thiscall` 是 C++ 类成员函数的常用调用惯例，将 `this` 指针高效地传递给成员函数。

| 调用惯例 | 特点 | 谁负责清理栈参数 | 函数名称修饰 |
| --- | --- | --- | --- |
| cdecl | 参数从右到左依次入栈 | 调用者 | 编译时不做修饰，保持原样 |
| stdcall | 参数从右到左依次入栈 | 被调用者 | 通常会添加一个后缀，如 `_` 或 `@n`，`n` 表示参数占用的字节数 |
| fastcall | 部分参数通过寄存器传递，其余参数从右到左入栈 | 被调用者 | 函数名称可能会有相应的修饰 |
| thiscall（C++ 特定） | 用于 C++ 类的成员函数调用，对于非静态成员函数，`this` 指针作为隐式的第一个参数传递，通常通过 `ecx` 寄存器传递，参数从右到左入栈 | 被调用者 | 无特殊说明 |

`thiscall`在不同编译器下的实现有所不同：在`VC`编译器中，`this`指针存放在`ecx`寄存器，参数从右到左压栈。对于`gcc`，`thiscall`和`cdecl`一样，将`this`看作是函数的第一个参数。

除了参数传递之外，函数与调用方的交互还涉及**返回值的传递**

* 通常返回值存在eax寄存器 4字节
* 联合eax edx寄存器，eax存低4字节，edx存高位1~4字节 5~8字节
* 超过8字节，如何返回？

例子

```c
typedef struct big_thing {
    char buf[128];
} big_thing;

big_thing return_test() {
    big_thing b;
    b.buf[0] = 0;
    return b;
}

int main() {
    big_thing n = return_test();
}
```

**对于超过8字节的返回值**，先说早起编译器实现的标准流程(来自MSVC19)：

1. main函数在栈上开辟内存空间，并将这个空间的一部分作为传递返回值的临时对象，称为temp
2. 将temp对象的地址作为隐藏参数传递给被调用函数
3. 被调用函数将数据拷贝给temp对象，并将temp对象的地址用eax传出
4. 被调用函数返回后，main函数将eax指向的temp对象的内容拷贝给n

在RVO存在的情况下，上述两次拷贝会被简化（来自GCC14）

```assembly
return_test():
        push    rbp                     ; 将调用者的基址指针（rbp）压入栈中，保存调用者的栈帧信息
        mov     rbp, rsp                ; 将栈指针（rsp）的值赋给基址指针（rbp），建立新的栈帧
        mov     QWORD PTR [rbp-8], rdi  ; 将第一个参数（存储在 rdi 中）存储到栈上的局部变量中，地址为 rbp-8
        mov     rax, QWORD PTR [rbp-8]  ; 将存储在 rbp-8 处的值（即之前存储的参数）加载到 rax 寄存器中
        mov     BYTE PTR [rax], 0       ; 将 rax 指向的内存位置的值置为 0。这里假设 rdi 是一个指针，将该指针所指向的内存位置的第一个字节置为 0
        nop                             ; 空操作，可能用于代码对齐或调试断点
        mov     rax, QWORD PTR [rbp-8]  ; 再次将存储在 rbp-8 处的值加载到 rax 寄存器中
        pop     rbp                     ; 从栈中弹出保存的基址指针，恢复调用者的栈帧
        ret                             ; 函数返回，返回到调用者
main:
        push    rbp                     ; 保存调用者（可能是操作系统启动代码）的基址指针，开始 `main` 函数的栈帧
        mov     rbp, rsp                ; 建立 `main` 函数的栈帧
        add     rsp, -128               ; 为 `main` 函数的局部变量分配 128 字节的栈空间
        lea     rax, [rbp-128]          ; 将 `rbp-128` 的地址加载到 rax 寄存器中
        mov     rdi, rax                ; 将 `rax` 的值（即栈上分配的 128 字节的起始地址）作为参数传递给 `return_test` 函数
        call    return_test()           ; 调用 `return_test` 函数
        mov     eax, 0                  ; 将返回值（在 `eax` 中）设置为 0，通常表示程序正常结束
        leave                           ; 等价于 `mov rsp, rbp; pop rbp`，清理 `main` 函数的栈帧
        ret                             ; 程序结束，返回到调用者（可能是操作系统）
```

## 堆和内存管理

内核管理进程的内存开销大，因为系统调用昂贵。通常是程序的运行库来管理（批发+零售）。

### Linux进程堆管理

`brk`：设置进程数据段的结束地址（Linux下数据段和BSS合并在一起统称数据段）。如果将数据段的结束地址向高地址移动，name扩大的那部分空间就可以被使用，将这块空间拿来作为新增的堆空间。
`mmap`：向操作系统申请一段虚拟地址空间，这块虚拟地址工具可以映射到某个文件。如果映射不存在时，则称之为匿名空间，匿名空间可以拿来作为堆空间。

### Window进程堆管理

略

### 堆分配算法

> 如何管理一大块练习的内存空间，能够按照需求分配、释放其中的空间

1. 空闲链表
   1. 堆内的空闲块按照链表方式管理起来，用户请求一块空间时，则遍历找到合适的大小，然后切分并分配给用户；用户释放空间时则合并到空闲链表
   2. 链表被破快 or 记录分配块长度的4字节被越界读写 则整个堆都无法正常工作
2. 位图
   1. 将堆划分为大量的块，每个块大小相同。当用户请求内存时，总是分配整数个块的空间给用户。
   2. 第一块为分配区域的头、剩下的块为分配区域的主体。因此块状态可以用`2bit`表示：头、主体、空闲
   3. 优点：速度快（位图存储为数组，cache容易命中），稳定性好（备份位图就可以防止被破坏），易于管理（不需要额外信息）
   4. 缺点：容易产生碎片、堆很大或者块很小时，位图的数组会很大
3. 对象池

实际上很多现实应用中，堆的分配算法往往是采取多种算法复合而成的。比如对于`glibc` 米说，它对于小于64字节的空间申请是采用类似于对象池的方法:而对于大于512字节的 空间申请采用的是最佳适配算法:对于大于64 字节而小于512字节的，它会根据情况采取上述方法中的最佳折中策略:对于大于128KB的申请，它会使用mmap 机制直接向操作系统申请空间。
