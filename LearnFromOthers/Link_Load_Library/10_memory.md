# Memory

## 程序内存布局

```c
// |-----------------------|   0xFFFFFFFF
// |      kernel space     |
// |-----------------------|   0xC0000000
// |        stack          |
// |-----------------------|
// |        unused         |
// |                       |
// |-----------------------|
// |   dynamic libraries   |
// |-----------------------|
// |                       |
// |                       |
// |        unused         |
// |-----------------------|
// |         heap          |
// |-----------------------|
// |  read/write sections  |
// |      (.data .bss)     |
// |-----------------------|
// |   readonly sections   |
// | (.init .rodata .text) |
// |-----------------------|   0x08048000
// |        reserved       |
// |-----------------------|   0x0
```

32位系统的典型内存分布：

1. 高位1GB位内核空间
2. 栈：维护函数调用上下文，向低地址增长
3. 动态链接库映射区：装载动态链接库
4. 堆：动态分配，向高地址增长
5. 可执行文件映像：装载可执行文件
6. 保留区：保护而禁止访问的区域的总称，通常极小地址不允许访问

## 栈和调用惯例

栈的内容：函数的返回地址和参数、临时变量、保存的上下文（调用前后需要保持不变的寄存器）

i386语义下，esp指向栈顶，ebp指向栈帧的起始位置，一种常见布局如下：

```c
// |-----------------------|
// |       parameters      |
// |-----------------------|
// |     return address    |
// |-----------------------| -->   ebp
// |        old ebp        |
// |-----------------------|
// |    saved registers    |
// |-----------------------|
// |    local variables    |
// |-----------------------|
// |    other datas        |
// |-----------------------| -->   esp
```

i386的调用过程：

1. 把所有或一部分参数压栈，如果有其他参数没有入栈，使用某些特定的寄存器传递
2. 把当前指令的下一条指令的地址压栈
3. 跳转到函数体执行

i386函数调用的汇编示例：

```c
push ebp            // old ebp
mov ebp, esp        // ebp = esp
【可选】sub esp, XXX // 栈上分配临时空间
【可选】push XXX     // 保存寄存器

......


【可选】pop XXX   // 恢复寄存器
mov esp, ebp    // 恢复esp，同时回收局部变量的空间
pop ebp         // 恢复ebp
ret             // 获取返回地址，并跳转
```
