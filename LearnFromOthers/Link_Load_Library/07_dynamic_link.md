# 动态链接

静态链接的问题是空间浪费、卡法和发布会受到依赖库的影响。

动态链接则不对组成程序的目标文件进行链接，等到程序要运行时才进行链接。好处：

* 减少空间浪费
* 依赖库升级方便，不需要整体重新编译
* 程序在运行时可以动态地加载各种程序模块（插件）
* 加强程序兼容性，在程序和运行平台之间的中间层

## 例子

```c
// program1.c
#include "Lib.h"

int main() {
    foobar(1);
    return 0;
}

// program2.c 
#include "Lib.h"

int main()
{
    foobar(2);
    return 0;
}

// Lib.c
#include <stdio.h>

void foobar(int i)
{
    printf("Printing from Lib.so %d\n", i);
    sleep(-1);
}

// Lib.h
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```

```shell
$ gcc -fPIC --shared -o Lib.so Lib.c
$ gcc -o program1 program1.c ./Lib.so 
$ gcc -o program2 program2.c ./Lib.so
```

通过观察运行仅在的虚拟内存分布可以看到，系统把：`program1` `Lib.so` `libc.so` `ld-2.28.so` 都映射到了进程的地址空间。因此对于一个动态链接的可执行文件，系统在开始`program1`之前，先把控制权交给动态链接器，由它完成所有链接工作之后，再把控制权交给`program1`，执行程序。

查看Lib.so的装载属性：

```shell
$ readelf -l -W Lib.so

Elf file type is DYN (Shared object file)
Entry point 0x1060
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x0004d0 0x0004d0 R   0x1000
  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000151 0x000151 R E 0x1000
  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x0000bc 0x0000bc R   0x1000
  LOAD           0x002e10 0x0000000000003e10 0x0000000000003e10 0x000220 0x000228 RW  0x1000
  DYNAMIC        0x002e20 0x0000000000003e20 0x0000000000003e20 0x0001c0 0x0001c0 RW  0x8
  NOTE           0x000238 0x0000000000000238 0x0000000000000238 0x000024 0x000024 R   0x4
  GNU_EH_FRAME   0x00201c 0x000000000000201c 0x000000000000201c 0x000024 0x000024 R   0x4
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
  GNU_RELRO      0x002e10 0x0000000000003e10 0x0000000000003e10 0x0001f0 0x0001f0 R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   01     .init .plt .plt.got .text .fini 
   02     .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .init_array .fini_array .dynamic .got 
```

和普通文件的不同点是：文件类型不同、起始地址是0x00000000，是一个无效地址。

实际装载地址并不是0x00000000，因此，**共享对象的最终装载地址在编译时是不确定的**

## 地址无关代码

**共享对象在编译时不能假设自己在进程虚拟地址空间中的位置**。可执行文件基本可以确定自己在进程虚拟空间中的起始地址，因为它通常是第一个被加载的，可以选择一个固定空闲的地址。

### 装载时重定位

装载时明确起始地址，利用偏移计算符号的实际装载地址。相对应的是前面提到的链接时重定位

缺陷是：指令无法再多个进程之间共享，因为每个进程装载时，空闲的地址可能是不同的，装载这个共享库时查找到的空闲的起始地址可能也是不同的，这就要求动态链接库中的可修改数据部分对于不同进程来说有多个副本。也就失去了内存节省的优点。

仅使用 `-shared` 就是装载时重定位

### 地址无关代码技术

希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分防在一起，这样指令部分就可以保持不变，数据部分可以在每个进程中拥有一个副本。这个方案就是地址无关代码（PIC，Position-independent Code）技术。

一般模块中的地址引用方式，可以分为以下四种：

**1. 模块内的函数调用、跳转**

被调用的函数和调用者在同一个模块，之间的相对位置是固定的。可以用相对地址调用，或者是基于寄存器的相对调用，这种指令是不需要重定位的。

**2. 模块内部的数据访问，如模块中定义的全局变量、静态变量**

指令中不能包含数据的绝对地址，唯一的办法就是相对寻址。任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。

**3. 模块外部的函数调用、跳转**

与下面类型的方式一样，GOT中保存的是目标函数的地址。这种方法简单，但存在一些性能问题，实际上ELF采用了更复杂和精巧的方法，参见后面对动态链接优化的分析。

**4. 模块外部的数据访问，如其他模块定义的全局变量**

其他模块的全局变量的地址是跟模块装载地址有关的。ELF的做法是在**数据段里面建立一个指向这些变量的指针数组**，也被称为**全局偏移表**（Global Offset Table，GOT）当代码需要引用该全局变量时，可以通过GOT中相对于的项间接引用。

GOT本质上就是模块内部的数据，利用它做了一次中转。

### 如何确认一个动态库是否是PIC的

`readelf -d xxx.so | grep TEXTREL` 没有输出

因为PIC不应该包含代码段重定位表，TEXTREL表示代码段重定位表地址。

### 全局变量问题

```c
// module.c
extern int global;
int foo() {
    global = 1;
}
```

编译器在编译上面文件时，无法根据这个上下文判断`global`是定义在同一个模块的其他目标文件还是定义在另外一个共享对象中，即无法判断是否为跨模块间的调用。

假设module.c 是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代 码并不是地址无关代码，也就是说代码不会使用这种类似于PIC的机制，它引用这个全局变量的方式跟普通数据访问方式一样，编译器会产生这样的代码:
`movl $0x1,XXXXXXXX`
`XXXXXXXX`就是 `global` 的地址。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的`.bss`段创建一个 `global` 变量的副本。那么问题就很明显了，现在 `global` 变量定义在原先的共享对象中，而在可执行文件的`.bss`段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。

于是解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。`ELF`共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过 `GOT` 来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把 `GOT`中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本，那么`GOT` 中的相应地址就指向模块内部的该变量副本。

假设module.c是一个共享对象的一部分，那么GCC编译器在`-fPIC`的情况下，就会把 对`global` 的调用按照跨模块模式产生代码。原因也很简单:编译器无法确定对`global` 的引用 是跨模块的还是模块内部的。即使是模块肉部的，即模块内部的全局变量的引用，按照上面 的结论，还是会产生跨模块代码，因为`global` 可能被可执行文件引用，从而使得共享模块中 对`global` 的引用要执行可执行文件中的`global` 副本。

### 数据段地址无关性
