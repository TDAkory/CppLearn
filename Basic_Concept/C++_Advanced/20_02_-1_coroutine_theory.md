# C++ 协程理论总结（基于 Lewis Baker 博客）

> https://lewissbaker.github.io/2017/09/25/coroutine-theory

## 1. 一段话总结

本文是 Lewis Baker 关于 C++ 协程的系列开篇，核心是将**协程（Coroutine）定义为函数的泛化形式**，通过在传统函数“调用（Call）”“返回（Return）”操作基础上，新增**暂停（Suspend）、恢复（Resume）、销毁（Destroy）** 三个关键操作，实现函数执行的“可中断与可续接”；同时详细对比了传统函数与协程在**激活帧（Activation Frame）存储**（传统函数依赖栈、协程需堆存储）、**生命周期嵌套性**（传统函数严格嵌套、协程非严格嵌套）的差异，并用实例图解了协程从调用、暂停到恢复的完整流程，为理解 C++ 协程 TS（最终纳入 C++20）的底层机制奠定理论基础。

## 详细总结

### 传统函数（Normal Functions）的核心机制

#### Call 与 Return

传统函数仅支持两种核心操作，流程严格且单向：

- **Call（调用）操作**：
  1. 调用者准备：保存 CPU 寄存器中的临时值（避免被调用函数覆盖）；
  2. 栈帧分配：在栈上为被调用函数创建**激活帧（Activation Frame）**，写入参数、返回地址（调用者后续恢复执行的指令地址）；
  3. 执行转移：将执行权转移到被调用函数的起始位置（X86/X64 用 `call` 指令完成，自动写入返回地址并跳转）。
- **Return（返回）操作**：
  1. 返回值存储：将返回值写入调用者可访问的位置（如调用者栈帧或寄存器）；
  2. 栈帧销毁：销毁被调用函数的局部变量、参数，释放栈帧内存（X64 中通过递减 `rsp` 寄存器实现）；
  3. 执行恢复：恢复调用者的栈帧（重置 `rsp` 寄存器），跳转到 Call 操作时存储的返回地址，继续执行调用者逻辑。

#### 激活帧（Activation Frame）的关键特性

存储函数单次调用状态的内存块，是传统函数执行的核心数据结构。存储：函数参数与局部变量的值、返回地址（调用者需恢复执行的指令地址）、调用者激活帧的地址（形成函数调用链）。

依赖**栈（Stack）** 数据结构，因传统函数的激活帧生命周期**严格嵌套**（父函数帧存活时，子函数帧才存在），分配/释放效率极高：分配：`rsp` 寄存器（栈顶指针）增加帧大小；释放：`rsp` 寄存器减少帧大小；

几乎所有 CPU 架构都为栈设计专用寄存器（如 X64 的 `rsp` 寄存器），确保操作高效。

### 协程（Coroutines）的核心机制

协程是传统函数的泛化，在 Call/Return 基础上新增 **Suspend（暂停）、Resume（恢复）、Destroy（销毁）** 操作，突破“单次调用→单次返回”的限制。

| 操作类型   | 触发时机 | 核心流程 | 关键特性 |
|----------|---------|-----------|------------|
| **Call**   | 调用者发起协程调用时              | 与传统函数一致：分配栈帧→写入参数/返回地址→转移执行权；<br>协程额外步骤：在堆上分配**协程帧（Coroutine Frame）**，将参数从栈帧复制到协程帧（确保参数生命周期覆盖暂停阶段） | 调用者视角与传统函数无差异，协程内部自动完成堆帧初始化                     |
| **Suspend**| 协程执行到 `co_await`/`co_yield` 时 | 1. 保存状态：将寄存器值写入协程帧，记录**暂停点（Resume Point）**（后续恢复的指令地址）；<br>2. 可选逻辑：执行暂停后回调（如调度后续恢复任务）；<br>3. 释放栈帧：仅保留堆上的协程帧，将执行权返回给调用者/恢复者 | 激活帧未销毁，局部变量保持存活；仅释放栈帧，堆帧持久化                     |
| **Resume** | 外部通过协程帧句柄调用 `resume()` 时 | 1. 激活帧：分配新栈帧，将协程帧地址加载到专用寄存器（如 MSVC 的 `rbp`）；<br>2. 恢复执行：从协程帧记录的暂停点跳转，继续执行协程逻辑；<br>3. 执行结束：协程再次暂停或返回时，`resume()` 调用返回，恢复调用者执行 | 需通过协程帧句柄定位具体协程实例；恢复后协程状态与暂停前完全一致           |
| **Destroy**| 外部通过协程帧句柄调用 `destroy()` 时 | 1. 激活帧：分配临时栈帧，加载协程帧地址；<br>2. 销毁资源：调用暂停点处所有存活局部变量的析构函数；<br>3. 释放内存：释放堆上的协程帧；<br>4. 恢复执行：`destroy()` 调用返回，恢复调用者执行 | 仅可对**已暂停**的协程执行；无需恢复协程逻辑，直接销毁资源                 |
| **Return** | 协程执行 `co_return` 时           | 1. 存储返回值：将返回值写入自定义位置（如协程帧或结果对象）；<br>2. 销毁资源：销毁暂停点处的局部变量（参数不销毁）；<br>3. 后续操作：执行回调逻辑（如通知等待者），再执行 Suspend 或 Destroy；<br>4. 转移执行权：返回调用者/恢复者 | 返回值生命周期独立于 Call 操作（可能在 Call 返回后很久才产生）；协程帧可能在 Return 后销毁或保留 |

#### 协程激活帧的特殊结构

因协程支持暂停，其激活帧从逻辑上看需拆分为两部分，分别应对“执行”与“暂停”状态：

- **协程帧（Coroutine Frame）**：
  - 存储位置：堆（Heap）；
  - 存储内容：参数、跨暂停点的局部变量、暂停点地址；
  - 生命周期：从协程调用开始，到 Destroy 操作结束，覆盖多次暂停/恢复；
- **栈帧（Stack Frame）**：
  - 存储位置：栈（Stack）；
  - 存储内容：仅当前执行阶段的临时变量、函数调用链信息；
  - 生命周期：仅在协程执行时存在，暂停时释放，恢复时重新分配。

满足前提时，编译器会将协程帧直接分配在调用者的激活帧（栈帧） 中，而非堆：

- 本质是 “复用调用者的栈空间”，避免堆分配的内存开销（如malloc/free的系统调用）和碎片问题（摘要 4 提到 “栈分配协程帧可避免堆开销”）。
- 注意：这种优化依赖编译器的 “智能分析”（如 Clang 15+、GCC 11 + 已支持），若协程逻辑复杂（如句柄被传递到外部），编译器无法证明生命周期嵌套，则仍会使用堆存储。

#### `Suspend`回调的设计目的

通过 **“先完成暂停、再调度恢复” 的时序设计**，规避了协程状态操作的竞争条件。

`C++20` 协程**暂停操作的内在时序**——暂停并非“瞬间完成”，而是分“准备阶段”和“稳定阶段”两步，这是后续无同步设计的基础

暂停的两步流程（以 `co_await` 为例）

| 阶段 | 核心操作 | 协程状态 | 关键特性  |
|---|--------|------------|-----------|
| 1. 暂停准备阶段     | ① 保存协程帧状态（局部变量、寄存器值、当前执行位置）；② 标记暂停点（如状态机的“label”，摘要3）；③ 执行 `awaiter.await_suspend()` 前的状态校验 | 不稳定（过渡态）         | 状态未完全固定，若此时被外部干扰（如发起恢复），会导致状态读取不完整       |
| 2. 稳定暂停阶段     | ① 完成状态保存，协程帧进入“只读状态”（不再修改）；② 释放当前线程资源（如栈帧，摘要6）；③ 调用 `awaiter.await_suspend(h)`（传入协程句柄 `h`） | 稳定（暂停态）           | 状态已完整固化，外部可安全通过句柄 `h` 发起恢复，无需担心状态变化         |

**关键结论**：只有当协程完成“准备阶段”进入“稳定暂停阶段”后，其状态才是“可安全访问”的；未完成准备阶段的协程处于“过渡态”，状态随时可能变化，此时操作会引发不一致。

当协程进入“稳定暂停阶段”后再调度恢复，本质是访问“只读的固化状态”，不存在竞争条件，因此无需同步（如互斥锁、原子操作），具体原因有三点：

1. 协程在稳定暂停阶段会将所有关键状态（局部变量、暂停点地址、寄存器备份）完整保存到**堆上的协程帧**中，且此后直到恢复前，不会有任何操作修改该帧（协程自身已暂停，外部仅读取不修改）。  
2. 协程稳定暂停后，外部调度恢复的操作（如通过 `await_suspend` 注册到调度器）具有“单向性”：仅读取协程帧状态，不修改除“执行位置”外的其他状态（执行位置的修改是恢复流程的原子步骤，由编译器保证）。  
3. C++20 协程通过 `awaiter.await_suspend()` 函数，强制“调度恢复”发生在稳定暂停后  

**为何“暂停前调度恢复必须同步”？**

若在协程进入稳定暂停阶段**之前**（即“暂停准备阶段”）就发起恢复，会导致“协程暂停”与“外部恢复”两个操作同时修改/访问协程状态，产生**竞争条件**，必须通过同步（如互斥锁、原子标志）来避免，具体原因如下：

1. “暂停准备阶段”的协程处于“过渡态”：状态（如局部变量、暂停点）正在被修改（保存），此时外部发起恢复，会出现“两个操作同时读写同一资源”的冲突
2. 为避免上述竞争，必须在“暂停准备阶段”和“恢复操作”之间加入同步机制（如互斥锁 `std::mutex`），确保两个操作“互斥执行”,同步会引入额外开销（如锁的获取/释放、线程阻塞），违背协程“轻量级”的设计目标。

**`C++20` 协程的设计巧思：通过流程约束规避同步**

这一特性，本质是 C++20 协程通过“流程时序约束”（先暂停、后调度恢复），从设计上消除了同步的必要性，具体体现在两个层面：

1. 编译器层面：强制暂停流程的原子性边界.编译器会将协程的暂停过程编译为“不可中断的原子步骤”（从准备阶段到稳定阶段），不允许外部操作插入到中间
2. 库层面：await_suspend 的“调度入口”角色.C++20 协程将“调度恢复”的逻辑统一放在 `awaiter.await_suspend()` 中，而该函数的调用时机被严格限制在“协程进入稳定暂停后”

### 传统函数与协程的核心差异对比

| 对比维度 | 传统函数（Normal Functions）| 协程（Coroutines）|
|---------|--------------|-----------------------|
| 核心操作                | Call、Return                                           | Call、Return、Suspend、Resume、Destroy               |
| 激活帧存储              | 仅栈（Stack）                                          | 栈（执行时）+ 堆（暂停时）                          |
| 激活帧生命周期          | 严格嵌套（子帧存活依赖父帧）                          | 非严格嵌套（协程帧可独立于调用者帧存活）            |
| 执行流程                | 单次调用→单次返回，不可中断                            | 调用→多次暂停/恢复→返回，可中断续接                |
| 局部变量生命周期        | 与函数调用同步（调用时创建，返回时销毁）                | 跨暂停点存活（暂停时不销毁，Destroy 时才销毁）      |
| 硬件依赖                | 仅依赖栈寄存器（如 `rsp`）                            | 额外依赖协程帧寄存器（如 `rbp`）                    |
| 典型应用场景            | 同步、无中断的计算逻辑                                | 异步 I/O、迭代器生成、状态机等需中断续接的场景      |

### illustration

![illustration](https://raw.githubusercontent.com/TDAkory/ImageResources/master/img/CppLearn/coroutine_illustration.jpg)

### 关键问题

#### 问题1：协程为何不能像传统函数一样仅依赖栈存储激活帧？核心原因是什么？

核心原因是协程的**激活帧生命周期不满足严格嵌套**。  

传统函数的激活帧严格嵌套（子函数调用时父帧存在，子帧销毁后父帧才继续执行），因此可通过栈的“先进后出”特性高效管理；而协程支持暂停操作，暂停时需保留激活帧（局部变量、参数），但此时调用者可能已执行完毕（栈帧被销毁），若协程帧存储在栈上会随调用者栈帧释放而丢失。因此协程需将核心状态（参数、暂停点）存储在堆上，仅将临时执行状态（当前调用链）存储在栈上，确保暂停后状态不丢失。

#### 问题2：C++ 协程中 `co_await`/`co_yield` 和 `co_return` 的核心作用是什么？与传统函数的 `return` 有何本质区别？

协程存在 “两次返回” 的逻辑分离：一次是 “Call 操作的返回”（给调用者一个 “协程控制载体”），另一次是 “Return 操作的返回”（给调用者协程的 “最终业务结果”），二者不仅类型、用途不同，产生时机也可能相差极远。

1. `co_await`/`co_yield` 的核心作用是**标记暂停点**：  
   当协程执行到这两个关键字时，触发 Suspend 操作，保存当前状态（寄存器值、暂停点），释放栈帧并返回执行权；其中 `co_yield` 还会对外返回一个“产出值”（如迭代器的下一个元素），`co_await` 则等待一个异步操作完成（如 I/O 就绪）后再恢复。  
2. `co_return` 的核心作用是**标记协程最终返回**：  
   执行时存储返回值，销毁暂停点处的局部变量，执行回调逻辑后选择 Suspend（保留帧）或 Destroy（释放帧），与传统函数 `return` 的本质区别在于：  
   - 传统函数 `return` 后栈帧立即销毁，返回值直接传递给调用者；  
   - `co_return` 后协程帧可能继续存活（如需异步传递返回值），返回值生命周期独立于初始 Call 操作（可能在 Call 返回后很久才产生）。

#### 问题3：协程的 `Destroy` 操作与传统函数的 `Return` 操作在“资源销毁”上有何差异？为何 `Destroy` 操作仅能对已暂停的协程执行？

1. 资源销毁差异:

   | 操作类型   | 销毁范围  | 执行时机  | 核心目标 |
   |----------|----|--------|-------|
   | 传统函数 Return | 局部变量、参数、栈帧              | 函数执行完毕，返回调用者前        | 释放当前函数的所有临时资源        |
   | 协程 Destroy    | 暂停点处的局部变量、协程帧        | 外部主动调用，无需恢复协程执行    | 安全释放暂停协程的持久化资源      |  

   关键差异：`Return` 销毁的是“执行完毕的函数资源”，`Destroy` 销毁的是“暂停中协程的未释放资源”，且 `Destroy` 不执行协程剩余逻辑，仅做资源清理。  

2. Destroy 仅能对已暂停协程执行的原因：  

   若协程处于**执行中**（未暂停），其栈帧正在使用（如执行函数调用、修改局部变量），此时销毁协程帧会导致栈数据混乱、资源访问冲突（如局部变量析构时栈帧已被覆盖）；而协程**暂停时**，栈帧已释放，核心状态仅存于堆帧，且局部变量状态固定，此时执行 Destroy 可安全调用析构函数并释放堆内存，避免数据竞争或资源泄漏。
