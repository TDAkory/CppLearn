# Fast hints

> Jeffrey Dean & Sanjay Ghemawat, Performance Hints, 2025, https://abseil.io/fast/hints.html

## BaseLine

**完整的“过早优化”观点**：Knuth并非否定所有提前优化，而是强调**97%的场景下可忽略小效率问题，避免因过早优化引入bug和维护难题**；但**关键的3%场景中，绝不能放弃优化机会**，这份文档正是聚焦这一核心场景。

**Knuth对“小幅度优化”的立场**：很多人认为12%的性能提升微不足道，这是软件工程师对“抠细节优化导致代码不可维护”的过度反应；而在成熟工程领域，12%的易实现提升绝非边际收益，**软件工程也应秉持这一视角**——非一次性任务的高质量程序开发中，不应拒绝这类不影响代码质量的效率提升。

“先简单写代码，后续靠性能分析优化”，这种主流观点存在四大致命缺陷，导致实际中难以有效优化：

1. **性能损耗分散化**：大型系统开发中完全忽视性能，会出现**无明显热点的扁平性能剖面**，性能问题遍布各处，无法确定优化切入点。
2. **库开发的场景限制**：若开发的是供他人使用的库，使用者往往难以理解库的内部细节，也无法与开发团队协商优化，最终只能承受性能问题。
3. **系统上线后的修改成本高**：系统投入高频使用后，大幅修改代码以优化性能的难度会急剧增加。
4. **误判性能问题的解决成本**：容易忽略可轻松解决的性能问题，最终被迫采用高成本方案（如服务过度复制、资源超配）来应对负载问题。

在编写代码时，**若更快的实现方案不会显著影响代码的可读性和复杂度，应优先选择该方案**——这是平衡性能与代码质量的核心原则。

```shell
# rough costs for some basic low-level operations for estimation
L1 cache reference                             0.5 ns
L2 cache reference                             3 ns
Branch mispredict                              5 ns
Mutex lock/unlock (uncontended)               15 ns
Main memory reference                         50 ns
Compress 1K bytes with Snappy              1,000 ns
Read 4KB from SSD                         20,000 ns
Round trip within same datacenter         50,000 ns
Read 1MB sequentially from memory         64,000 ns
Read 1MB over 100 Gbps network           100,000 ns
Read 1MB from SSD                      1,000,000 ns
Disk seek                              5,000,000 ns
Read 1MB sequentially from disk       10,000,000 ns
Send packet CA->Netherlands->CA      150,000,000 ns
```

**性能分析（Profiling）的工具推荐、实用技巧**，以及的内容，明确高效的性能分析方法和针对性的优化方向。

1. **首选通用工具**：`pprof`，优势是能提供**高层级的性能信息**，且在本地开发和生产环境中都易于使用，是性能分析的入门首选。
2. **进阶深度工具**：`perf`，适合需要获取**更详细的性能洞察**（如硬件层面的性能指标）的场景。
3. **专项场景工具**：
   - 锁竞争分析：部分互斥锁（mutex）的实现自带锁竞争分析支持，可定位锁导致的CPU利用率虚低问题。
   - 机器学习场景：使用专门的ML性能分析器，适配机器学习任务的性能分析需求。

为了让性能分析和优化更高效、准确，需遵循以下实操技巧：

1. **编译配置优化**：构建生产环境的二进制文件时，要带上**适当的调试信息和优化标志**——既保留性能，又能在分析时定位到具体代码行。
2. **编写微基准测试（Microbenchmark）**：
   - 作用：缩短性能优化的周转时间，验证优化效果，防止后续性能回归。
   - 注意：微基准测试可能无法代表全系统性能（存在局限性），且有C++、Go、Java等语言的成熟库支持。
3. **利用性能计数器**：使用基准测试库输出**硬件性能计数器读数**，既能提升性能数据的精度，又能更深入地理解程序的运行行为。

**面对扁平CPU性能剖面（无明显性能热点）时的解决策略**：当CPU性能剖面呈现“扁平”状态（性能损耗分散，无明显热点），且低难度优化已完成时，可采取以下针对性策略：

1. **重视小优化的累积效应**：实现20个独立的1%优化是完全可行的，其累积效果会非常显著（这类优化依赖稳定、高质量的微基准测试支撑）。
2. **优化调用栈顶层的循环**：通过CPU剖面的**火焰图**找到调用栈顶层的循环，重构循环或其调用的代码（例如：将“增量构建复杂数据结构”改为“一次性传入全部输入构建”，减少原代码中逐元素的冗余检查）。
3. **转向结构性/算法级优化**：跳出微优化的局限，从调用栈高层寻找**结构性改进**，借助算法优化技巧（而非仅调整代码细节）解决性能问题。
4. **替换过度通用的代码**：用定制化、更低层级的实现替代过于通用的代码（例如：用简单的前缀匹配代替耗时的正则表达式匹配）。
5. **减少内存分配**：
   - 步骤：获取内存分配剖面，优先优化分配数量最多的源头。
   - 效果：①减少分配器（及GC语言的垃圾回收）的耗时；②降低缓存未命中（如使用tcmalloc的长期运行程序中，频繁分配会导致缓存行分散）。
6. **收集硬件性能计数器剖面**：借助`perf`等工具收集基于硬件性能计数器的剖面，定位到**缓存未命中率高的函数**，针对性优化。

## API considerations
