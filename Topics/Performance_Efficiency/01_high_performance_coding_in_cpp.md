# C++é«˜æ€§èƒ½ç¼–ç¨‹

> [C++ é«˜æ€§èƒ½ç¼–ç¨‹ï¼ˆå…¨ï¼‰](https://www.cnblogs.com/apachecn/p/18172912)
> [C++ High Performance, Second Edition: Master the art of optimizing the functioning of your C++ code](https://www.amazon.com/dp/1839216549)

**é›¶å¼€é”€åŸåˆ™**ï¼šä½ ä¸ä½¿ç”¨çš„ä¸œè¥¿ï¼Œä½ å°±ä¸éœ€è¦ä»˜è´¹ï¼›ä½ ä½¿ç”¨çš„ä¸œè¥¿ï¼Œä½ æ— æ³•æ‰‹å·¥ç¼–ç å¾—æ›´å¥½

ä¸€äº› C++ çš„æ—§ä½†å¼ºå¤§çš„ç‰¹æ€§ï¼Œè¿™äº›ç‰¹æ€§ä¸å¥å£®æ€§æœ‰å…³ï¼Œè€Œä¸æ˜¯æ€§èƒ½ï¼Œå¾ˆå®¹æ˜“è¢«å¿½è§†ï¼šå€¼è¯­ä¹‰ã€constæ­£ç¡®æ€§ã€æ‰€æœ‰æƒã€ç¡®å®šæ€§é”€æ¯å’Œå¼•ç”¨ã€‚

> åœ¨å†…éƒ¨ï¼Œå¼•ç”¨æ˜¯ä¸€ä¸ªä¸å…è®¸ä¸ºç©ºæˆ–é‡æ–°æŒ‡å‘çš„æŒ‡é’ˆï¼›å› æ­¤ï¼Œå½“å°†å…¶ä¼ é€’ç»™å‡½æ•°æ—¶ä¸æ¶‰åŠå¤åˆ¶ã€‚

**C++çš„ç¼ºç‚¹**ï¼šé•¿æ—¶é—´çš„ç¼–è¯‘æ—¶é—´å’Œå¯¼å…¥åº“çš„å¤æ‚æ€§ï¼ˆç›´åˆ° C++20ï¼ŒC++ä¸€ç›´ä¾èµ–äºä¸€ä¸ªè¿‡æ—¶çš„å¯¼å…¥ç³»ç»Ÿï¼‰ï¼›ç¼ºä¹æä¾›çš„åº“ï¼ˆC++æä¾›çš„å‡ ä¹åªæ˜¯æœ€åŸºæœ¬çš„ç®—æ³•ã€çº¿ç¨‹ï¼Œä»¥åŠä» C++17 å¼€å§‹çš„æ–‡ä»¶ç³»ç»Ÿå¤„ç†ï¼Œå›¾å½¢ã€ç”¨æˆ·ç•Œé¢ã€ç½‘ç»œã€çº¿ç¨‹ã€èµ„æºå¤„ç†ç­‰åªèƒ½ä¾èµ–å¤–éƒ¨åº“ï¼‰

## 2. åŸºæœ¬C++æŠ€æœ¯

### `auto`è‡ªåŠ¨ç±»å‹æ¨åˆ°

**åœ¨å‡½æ•°ç­¾åä¸­ä½¿ç”¨ `auto`**

| æ˜¾å¼ç±»å‹çš„ä¼ ç»Ÿè¯­æ³•                       | ä½¿ç”¨ `auto` çš„æ–°è¯­æ³•                |
| ---------------------------------------- | ----------------------------------- |
| `int val() const { return m_; }`         | `auto val() const { return m_; }`   |
| `const int& cref() const { return m_; }` | `auto& cref() const { return m_; }` |
| `int& mref() { return m_; }`             | `auto& mref() { return m_; }`       |

**ä½¿ç”¨ `decltype(auto)` è¿›è¡Œè¿”å›ç±»å‹è½¬å‘**

```cpp
int val_wrapper() { return val(); }    // è¿”å› int
int& mref_wrapper() { return mref(); } // è¿”å› int&

auto val_wrapper() { return val(); }   // è¿”å› int
auto mref_wrapper() { return mref(); } // ä¹Ÿè¿”å› int

decltype(auto) val_wrapper() { return val(); }   // è¿”å› int
decltype(auto) mref_wrapper() { return mref(); } // è¿”å› int&
```

**ä½¿ç”¨ `auto` å£°æ˜å˜é‡**

```cpp
auto i = 0;
auto x = Foo{};
auto y = create_object();
auto z = std::mutex{};     // OK si
```

åœ¨ `C++17` ä¸­å¼•å…¥äº†ä¿è¯çš„æ‹·è´çœç•¥ï¼Œè¯­å¥`auto x = Foo{}`ä¸`Foo x{}`æ˜¯ç›¸åŒçš„ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œè¯­è¨€ä¿è¯åœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰éœ€è¦ç§»åŠ¨æˆ–å¤åˆ¶çš„ä¸´æ—¶å¯¹è±¡ã€‚

ä½¿ç”¨`auto`å®šä¹‰å˜é‡çš„ä¸€ä¸ªå¾ˆå¤§çš„ä¼˜åŠ¿æ˜¯ï¼Œæ°¸è¿œä¸ä¼šç•™ä¸‹æœªåˆå§‹åŒ–çš„å˜é‡ï¼Œå› ä¸º`auto x;`ä¸ä¼šç¼–è¯‘ã€‚

`const auto&`è¡¨ç¤ºï¼Œå…·æœ‰ç»‘å®šåˆ°ä»»ä½•ä¸œè¥¿çš„èƒ½åŠ›ã€‚åŸå§‹å¯¹è±¡æ°¸è¿œä¸ä¼šé€šè¿‡è¿™æ ·çš„å¼•ç”¨å‘ç”Ÿå˜å¼‚ã€‚æ˜¯æ½œåœ¨æ˜‚è´µçš„å¯¹è±¡çš„é»˜è®¤é€‰æ‹©ã€‚

`auto&`æ¥è¡¨ç¤ºå¯å˜å¼•ç”¨ã€‚åªæœ‰åœ¨æ‰“ç®—æ›´æ”¹å¼•ç”¨çš„å¯¹è±¡æ—¶æ‰ä½¿ç”¨å¯å˜å¼•ç”¨ã€‚

`auto&&`è¢«ç§°ä¸ºè½¬å‘å¼•ç”¨ï¼ˆä¹Ÿç§°ä¸ºé€šç”¨å¼•ç”¨ï¼‰ã€‚å®ƒå¯ä»¥ç»‘å®šåˆ°ä»»ä½•ä¸œè¥¿ï¼Œè¿™å¯¹æŸäº›æƒ…å†µå¾ˆæœ‰ç”¨ã€‚è½¬å‘å¼•ç”¨å°†åƒ`const`å¼•ç”¨ä¸€æ ·ï¼Œå»¶é•¿ä¸´æ—¶å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚ä½†ä¸`const`å¼•ç”¨ç›¸åï¼Œ`auto&&`å…è®¸æˆ‘ä»¬æ”¹å˜å®ƒå¼•ç”¨çš„å¯¹è±¡ï¼ŒåŒ…æ‹¬ä¸´æ—¶å¯¹è±¡ã€‚

ä¾¿äºä½¿ç”¨çš„å®è·µå»ºè®®

* åŸºæœ¬ç±»å‹å’Œå°çš„éåŸºæœ¬ç±»å‹ï¼šä½¿ç”¨ const autoã€‚
* æ½œåœ¨æ˜‚è´µçš„å¤§å‹ç±»å‹ï¼šä½¿ç”¨ const auto&ã€‚
* éœ€è¦å¯å˜å¼•ç”¨ï¼šä½¿ç”¨ auto&ã€‚
* è½¬å‘ä»£ç ï¼šä½¿ç”¨ auto&&ã€‚

[æŒ‡é’ˆçš„constä¼ æ’­](../../Basic_Concept/C++_Advanced/50_propagate_const.md)

### ç§»åŠ¨è¯­ä¹‰

åªæœ‰åœ¨å¯¹è±¡ç±»å‹æ‹¥æœ‰æŸç§èµ„æºï¼ˆæœ€å¸¸è§çš„æƒ…å†µæ˜¯å †åˆ†é…çš„å†…å­˜ï¼‰æ—¶ï¼Œç§»åŠ¨å¯¹è±¡æ‰æœ‰æ„ä¹‰ã€‚å¦‚æœæ‰€æœ‰æ•°æ®éƒ½åŒ…å«åœ¨å¯¹è±¡å†…éƒ¨ï¼Œç§»åŠ¨å¯¹è±¡çš„æœ€æœ‰æ•ˆæ–¹å¼å°±æ˜¯ç®€å•åœ°å¤åˆ¶å®ƒã€‚

**äº”æ³•åˆ™**ï¼Œ**ä¸‰æ³•åˆ™**ã€ç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼ã€‚

C++11å¼•å…¥ç§»åŠ¨è¯­ä¹‰ä¹‹å‰ï¼Œæ˜¯**ä¸‰æ³•åˆ™**ï¼Œæ‹·è´æ„é€ ã€æ‹·è´èµ‹å€¼ã€ææ„ã€‚

ç›¸å¯¹äºæ‹·è´ï¼Œç§»åŠ¨å‡½æ•°ä¸ä¼šåˆ†é…å†…å­˜æˆ–æ‰§è¡Œå¯èƒ½å¼•å‘å¼‚å¸¸çš„æ“ä½œï¼Œé€šå¸¸å¯ä»¥æ ‡è®°ä¸º `noexcept`

ä¸è¦å¿˜è®°å°†æ‚¨çš„ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦æ ‡è®°ä¸ºnoexceptï¼ˆé™¤éå®ƒä»¬å¯èƒ½æŠ›å‡ºå¼‚å¸¸ï¼‰ã€‚ä¸æ ‡è®°å®ƒä»¬ä¸ºnoexceptä¼šé˜»æ­¢æ ‡å‡†åº“å®¹å™¨å’Œç®—æ³•åœ¨æŸäº›æ¡ä»¶ä¸‹ä½¿ç”¨å®ƒä»¬ï¼Œè€Œæ˜¯è½¬è€Œä½¿ç”¨å¸¸è§„çš„å¤åˆ¶/èµ‹å€¼ã€‚è¯¦è§[vectorå’Œæ€§èƒ½é€€åŒ–](../../Basic_Concept/Things_About/Things_about_vector_pessimization.md)

é‚£ä¹ˆï¼Œç¼–è¯‘å™¨ä½•æ—¶å…è®¸ç§»åŠ¨å¯¹è±¡è€Œä¸æ˜¯å¤åˆ¶å‘¢ï¼Ÿç®€çŸ­çš„ç­”æ¡ˆæ˜¯ï¼Œå½“å¯¹è±¡å¯ä»¥è¢«å½’ç±»ä¸º rvalue æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç§»åŠ¨å¯¹è±¡ã€‚ rvalue æœ¬è´¨æ˜¯ä¸ä¸å‘½åå˜é‡ç»‘å®šçš„å¯¹è±¡ï¼šç›´æ¥æ¥è‡ªå‡½æ•°ã€`std::move`æ˜¾ç¤ºå£°æ˜

```cpp
// https://godbolt.org/z/Gs8aMaxjf
#include <iostream>
 
class Button { 
public: 
  Button() {} 
  auto set_title(const std::string& s) { 
    std::cout << "Copy assign" << std::endl;
    title_ = s; 
  } 
  auto set_title(std::string&& s) { 
    std::cout << "Move assign" << std::endl;
    title_ = std::move(s); 
  } 
  std::string title_; 
}; 

auto get_ok() {
  return std::string("OK");
}
auto button = Button{}; 
 
int main()
{
    auto str = std::string{"OK"};
    button.set_title(str);              // copy-assigned 
    button.set_title(std::move(str));   // move-assigned 
    button.set_title(get_ok());        // move-assigned 
    {
        auto str = get_ok();
        button.set_title(str);             // copy-assigned 
    }
    {
        const auto str = get_ok();
        button.set_title(std::move(str));  // copy-assigned 
    }
}
```

å¾—åˆ°çš„ç»“æœ

```shell
Copy assign
Move assign
Move assign
Copy assign
Copy assign
```

å¦‚æœæˆ‘ä»¬ä¸å£°æ˜ä»»ä½•è‡ªå®šä¹‰å¤åˆ¶æ„é€ å‡½æ•°/å¤åˆ¶èµ‹å€¼æˆ–ææ„å‡½æ•°ï¼Œç§»åŠ¨æ„é€ å‡½æ•°/ç§»åŠ¨èµ‹å€¼å°†è¢«éšå¼å£°æ˜ã€‚

* é›¶è§„åˆ™ï¼šå°½é‡é¿å…æ˜¾å¼ç¼–å†™å¤åˆ¶/ç§»åŠ¨æ„é€ å‡½æ•°ã€èµ‹å€¼è¿ç®—ç¬¦å’Œææ„å‡½æ•°ã€‚å¦‚æœéœ€è¦ï¼Œä½¿ç”¨ default æˆ–å®Œå…¨ä¸å®šä¹‰è¿™äº›å‡½æ•°ã€‚
* ç©ºææ„å‡½æ•°ï¼šé¿å…ä½¿ç”¨ç©ºææ„å‡½æ•°ï¼Œå› ä¸ºå®ƒå¯èƒ½ä¼šé˜»æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–ã€‚ä½¿ç”¨é»˜è®¤ææ„å‡½æ•°æˆ–å®Œå…¨ä¸å®šä¹‰ææ„å‡½æ•°ï¼Œä»¥ä¾¿åœ¨åº”ç”¨ç¨‹åºä¸­è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚

```cpp
#include <algorithm>

struct Point {
    int x_, y_;
    ~Point() {}  // ç©ºææ„å‡½æ•°ï¼Œä¸æ¨èä½¿ç”¨ï¼
};

auto copy(Point* src, Point* dst) {
    std::copy(src, src + 64, dst);
}

struct Point2 {
    int x_, y_;
    ~Point2() = default;
};

auto copy2(Point2* src, Point2* dst) {
    std::copy(src, src + 64, dst);
}
```

åœ¨ğŸ†•6-64 GCC 7.1 -O2ä¸‹å¾—åˆ°çš„æ±‡ç¼–ï¼šç”±äº `Point2` ç±»ä½¿ç”¨äº†é»˜è®¤ææ„å‡½æ•°ï¼ˆæˆ–æ²¡æœ‰ææ„å‡½æ•°ï¼‰ï¼Œç¼–è¯‘å™¨å¯ä»¥å°†å…¶è§†ä¸ºå¹³å‡¡ç±»å‹ï¼ˆ`trivially copyable`ï¼‰ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ `memmove` è¿›è¡Œä¼˜åŒ–ã€‚`memmove` æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„å†…å­˜å¤åˆ¶å‡½æ•°ï¼Œé€šå¸¸æ¯”æ‰‹åŠ¨å¾ªç¯å¤åˆ¶æ›´å¿«ã€‚

```asm
copy(Point*, Point*):
        xor     eax, eax                    ; å°† eax å¯„å­˜å™¨æ¸…é›¶ï¼Œç”¨äºåˆå§‹åŒ–å¾ªç¯è®¡æ•°å™¨
.L2:
        mov     rdx, QWORD PTR [rdi+rax]    ; ä»æºåœ°å€ rdi åŠ ä¸Šåç§»é‡ rax å¤„åŠ è½½8å­—èŠ‚ï¼ˆä¸€ä¸ª Point å¯¹è±¡ï¼‰åˆ° rdx å¯„å­˜å™¨
        mov     QWORD PTR [rsi+rax], rdx    ; rdx å¯„å­˜å™¨çš„å†…å®¹å­˜å‚¨åˆ°ç›®æ ‡åœ°å€ rsi åŠ ä¸Šåç§»é‡ rax å¤„
        add     rax, 8                      ; å°†å¾ªç¯è®¡æ•°å™¨ rax å¢åŠ  8 å­—èŠ‚ï¼ˆä¸€ä¸ª Point å¯¹è±¡çš„å¤§å°ï¼‰
        cmp     rax, 512                    ; æ¯”è¾ƒ rax å’Œ 512ï¼ˆå³ 64 ä¸ª Point å¯¹è±¡çš„æ€»å¤§å°ï¼‰
        jne     .L2                         ; å¦‚æœä¸ç›¸ç­‰ï¼Œè·³è½¬å›å¾ªç¯æ ‡ç­¾ .L2 ç»§ç»­å¤åˆ¶
        rep ret
copy2(Point2*, Point2*):
        mov     rax, rdi                    ; å°†æºåœ°å€ rdi ä¿å­˜åˆ° rax å¯„å­˜å™¨
        mov     edx, 512                    ; å¤åˆ¶çš„å­—èŠ‚æ•°ï¼ˆ512 å­—èŠ‚ï¼‰åŠ è½½åˆ° edx å¯„å­˜å™¨
        mov     rdi, rsi                    ; å°†ç›®æ ‡åœ°å€ rsi åŠ è½½åˆ° rdi å¯„å­˜å™¨
        mov     rsi, rax                    ; å°†æºåœ°å€ rax åŠ è½½åˆ° rsi å¯„å­˜å™¨
        jmp     memmove                     ; è·³è½¬åˆ° memmove å‡½æ•°ï¼Œä½¿ç”¨ memmove è¿›è¡Œä¼˜åŒ–çš„å†…å­˜å¤åˆ¶
```

å¯ä»¥å‘ç±»çš„æˆå‘˜å‡½æ•°æ·»åŠ `&&`ä¿®é¥°ç¬¦ï¼Œå°±åƒå¯ä»¥å‘æˆå‘˜å‡½æ•°åº”ç”¨`const`ä¿®é¥°ç¬¦ä¸€æ ·ã€‚ä¸`const`ä¿®é¥°ç¬¦ä¸€æ ·ï¼Œå…·æœ‰`&&`ä¿®é¥°ç¬¦çš„æˆå‘˜å‡½æ•°åªæœ‰åœ¨å¯¹è±¡æ˜¯å³å€¼æ—¶æ‰ä¼šè¢«é‡è½½è§£æè€ƒè™‘:

```cpp
#include <memory>

struct Foo { 
  auto func() && {} 
}; 
auto a = Foo{}; 
a.func();            // Doesn't compile, 'a' is not an rvalue 
std::move(a).func(); // Compiles 
Foo{}.func();        // Compiles 
```

å‡½æ•°è¿”å›å€¼ä¸è¦å†™`std::move()`ï¼Œä¼šé˜»æ­¢ç¼–è¯‘å™¨ä½¿ç”¨è¿”å›å€¼ä¼˜åŒ–ï¼ˆRVOï¼‰ï¼Œ`RVO`ä¼šå®Œå…¨çœç•¥äº†å¯¹è±¡çš„å¤åˆ¶ï¼Œæ¯”ç§»åŠ¨æ›´æœ‰æ•ˆã€‚

### è®¾è®¡å¸¦æœ‰é”™è¯¯å¤„ç†çš„æ¥å£

- **é”™è¯¯ç±»å‹åŒºåˆ†**ï¼šéœ€åŒºåˆ†ç¼–ç¨‹é”™è¯¯ï¼ˆå¦‚è¿åå‡½æ•°å‰ç½®æ¡ä»¶ï¼‰å’Œè¿è¡Œæ—¶é”™è¯¯ï¼Œè¿è¡Œæ—¶é”™è¯¯åˆå¯åˆ†ä¸ºå¯æ¢å¤å’Œä¸å¯æ¢å¤çš„ã€‚ä¸å¯æ¢å¤é”™è¯¯ï¼ˆå¦‚å †æ ˆæº¢å‡ºï¼‰å¸¸å¯¼è‡´ç¨‹åºç»ˆæ­¢ï¼›éƒ¨åˆ†é”™è¯¯åœ¨ä¸åŒåº”ç”¨åœºæ™¯ä¸‹æ¢å¤æ€§ä¸åŒã€‚
- **æ ‡å‡†åº“è¡Œä¸º**ï¼šC++ æ ‡å‡†åº“åœ¨å†…å­˜è€—å°½æ—¶æŠ›å‡º `std::bad_alloc` å¼‚å¸¸ï¼Œä½†å†…å­˜è€—å°½é€šå¸¸ä¸å¯æ¢å¤ã€‚

**è®¾è®¡å¥‘çº¦**ï¼šå¥‘çº¦æ˜¯è°ƒç”¨è€…ä¸è¢«è°ƒç”¨è€…é—´çš„è§„åˆ™ï¼Œéƒ¨åˆ†æ— æ³•ç”¨ C++ ç±»å‹ç³»ç»Ÿè¡¨è¾¾ï¼š

* **å‰ç½®æ¡ä»¶**ï¼šè§„å®šè°ƒç”¨è€…è´£ä»»ï¼Œå¦‚è°ƒç”¨ `std::vector::pop_back()` æ—¶å‘é‡ä¸èƒ½ä¸ºç©ºã€‚
* **åç½®æ¡ä»¶**ï¼šè§„å®šå‡½æ•°è¿”å›æ—¶çš„èŒè´£ï¼Œå¦‚ `std::list::sort()` åå…ƒç´ åº”å‡åºæ’åˆ—ã€‚
* **ä¸å˜é‡**ï¼šåº”å§‹ç»ˆæˆç«‹çš„æ¡ä»¶ï¼ŒåŒ…æ‹¬å¾ªç¯ä¸å˜é‡å’Œç±»ä¸å˜é‡ã€‚ç±»ä¸å˜é‡å®šä¹‰å¯¹è±¡æœ‰æ•ˆçŠ¶æ€ï¼Œå¦‚ `std::vector` çš„ `size() <= capacity()`ã€‚

**ç±»ä¸å˜é‡**ï¼šå®šä¹‰å¯¹è±¡æœ‰æ•ˆçŠ¶æ€ï¼ŒæŒ‡å®šç±»å†…éƒ¨æ•°æ®æˆå‘˜å…³ç³»ã€‚æœ‰åŠ©äºè®¾è®¡é«˜å†…èšã€å°‘çŠ¶æ€çš„ç±»ï¼Œä½¿ç±»æ›´æ˜“ç”¨ã€æ˜“å‘ç°é”™è¯¯

```cpp
// ç±»ä¸å˜é‡åº”åœ¨ç±»çš„æ„é€ å‡½æ•°ã€ææ„å‡½æ•°å’Œæˆå‘˜å‡½æ•°ä¸­å¾—åˆ°ç»´æŠ¤ã€‚ä¾‹å¦‚
struct Widget {
    Widget() {
        // Initialize objectâ€¦
        // Check class invariant
    }
    ~Widget() {
        // Check class invariant
        // Destroy objectâ€¦
    }
    auto some_func() {
        // Check precondition (including class invariant)
        // Do the actual workâ€¦
        // Check postcondition (including class invariant)
    }
};
```

**åˆåŒç»´æŠ¤**: åˆåŒæ˜¯æ‚¨è®¾è®¡å’Œå®ç°çš„ API çš„ä¸€éƒ¨åˆ†ï¼Œå¸¸è§çš„ç»´æŠ¤æ–¹å¼åŒ…æ‹¬ï¼šä½¿ç”¨ Boost.Contract åº“ï¼›è®°å½•åˆåŒï¼ˆè¿è¡Œæ—¶ä¸æ£€æŸ¥ï¼Œæ–‡æ¡£æ˜“è¿‡æ—¶ï¼‰ï¼›ä½¿ç”¨ `static_assert()` å’Œ `assert()` å®ï¼›æ„å»ºè‡ªå®šä¹‰åº“ã€‚

`static_assert()` ç”¨äºç¼–è¯‘æ—¶éªŒè¯ï¼Œå¤±è´¥å¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼›`assert()` ç”¨äºè¿è¡Œæ—¶æ£€æŸ¥ï¼Œè°ƒè¯•å’Œæµ‹è¯•æ—¶å¯ç”¨ï¼Œå‘å¸ƒæ¨¡å¼å¯é€šè¿‡å®šä¹‰ `NDEBUG` ç¦ç”¨ã€‚

**é”™è¯¯å¤„ç†ç­–ç•¥**ï¼š

* ç¼–ç¨‹é”™è¯¯
  * **å¤„ç†åŸåˆ™**ï¼šä½¿ç”¨æ–­è¨€è®©å¼€å‘è€…æ„è¯†åˆ°é—®é¢˜ï¼Œæ— éœ€ç”¨å¼‚å¸¸æˆ–é”™è¯¯ä»£ç å¤„ç†ã€‚
  * **æ–­è¨€ä½œç”¨**ï¼šæ˜ç¡®ä»£ç ä½œè€…å‡è®¾ï¼Œé™åˆ¶éœ€å¤„ç†æƒ…å†µï¼Œæ–¹ä¾¿å›¢é˜Ÿåä½œã€‚
  * **æ–­è¨€å¤±è´¥å¤„ç†**ï¼šæ£€æŸ¥ä»£ç å’Œæ–­è¨€ï¼Œå¯èƒ½æ˜¯ä»£ç é”™è¯¯ã€æ–­è¨€é”™è¯¯æˆ–ä¸¤è€…çš†é”™ï¼Œéœ€ç›¸åº”ä¿®å¤ã€‚
  * **æ€§èƒ½å½±å“**ï¼šè¿è¡Œæ—¶æ–­è¨€å¯èƒ½é™ä½æµ‹è¯•æ„å»ºæ€§èƒ½ï¼Œä½†å‘å¸ƒç‰ˆæœ¬åº”å¿½ç•¥ã€‚
* å¯æ¢å¤çš„è¿è¡Œæ—¶é”™è¯¯
  * **å¤„ç†ç›®çš„**ï¼šå°†é”™è¯¯ä¼ é€’åˆ°å¯æ¢å¤æœ‰æ•ˆçŠ¶æ€çš„ä»£ç å¤„ã€‚
  * **ä¿¡å·æ–¹å¼**ï¼šå¯é€‰æ‹© C++ å¼‚å¸¸ã€é”™è¯¯ä»£ç ã€`std::optional`ã€`std::pair`ã€`boost::outcome` æˆ– `std::experimental::expected`ã€‚

**å¼‚å¸¸å¤„ç†**ï¼š

* **ä½¿ç”¨åœºæ™¯**ï¼šC++ æ ‡å‡†é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œæ„é€ å‡½æ•°å¤±è´¥æ—¶åªèƒ½ç”¨å¼‚å¸¸å‘å‡ºé”™è¯¯ã€‚
* **`noexcept` æ ‡è®°**ï¼šæ ‡è®°å‡½æ•°ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œç¼–è¯‘å™¨ä¸éªŒè¯ï¼Œä»å…¶æŠ›å‡ºå¼‚å¸¸ä¼šè°ƒç”¨ `std::terminate()`ï¼Œæœ‰æ—¶å¯ç”Ÿæˆæ›´å¿«ä»£ç ã€‚
* **å¼ºå¼‚å¸¸å®‰å…¨æ€§**ï¼šå‡½æ•°åº”åƒäº‹åŠ¡ä¸€æ ·ï¼Œè¦ä¹ˆæäº¤æ‰€æœ‰çŠ¶æ€æ›´æ”¹ï¼Œè¦ä¹ˆå®Œå…¨å›æ»šã€‚å¯ä½¿ç”¨å¤åˆ¶å’Œäº¤æ¢æƒ¯ç”¨æ³•å®ç°ï¼Œå¦‚åœ¨ä¸´æ—¶å‰¯æœ¬ä¸Šæ‰§è¡Œå¯èƒ½æŠ›å¼‚å¸¸æ“ä½œï¼Œå†ç”¨éæŠ›å‡º `swap()` ä¿®æ”¹å¯¹è±¡çŠ¶æ€ã€‚
* **è‡ªåŠ¨é‡Šæ”¾**ï¼šC++ å¯¹è±¡é”€æ¯å¯é¢„æµ‹ï¼Œå¦‚ `std::scoped_lock` é€€å‡ºä½œç”¨åŸŸæ—¶è‡ªåŠ¨è§£é”äº’æ–¥é‡ã€‚

æ”¾å¼ƒå¼‚å¸¸çš„ä¸¤ä¸ªä¸»è¦åŸå› ï¼š

* å³ä½¿ä¸æŠ›å‡ºå¼‚å¸¸ï¼ŒäºŒè¿›åˆ¶ç¨‹åºçš„å¤§å°ä¹Ÿä¼šå¢åŠ ã€‚å°½ç®¡è¿™é€šå¸¸ä¸æ˜¯é—®é¢˜ï¼Œä½†å®ƒå¹¶ä¸éµå¾ªé›¶å¼€é”€åŸåˆ™ï¼Œå› ä¸ºæˆ‘ä»¬ä¸ºæˆ‘ä»¬ä¸ä½¿ç”¨çš„ä¸œè¥¿ä»˜è´¹ã€‚
* æŠ›å‡ºå’Œæ•è·å¼‚å¸¸ç›¸å¯¹æ˜‚è´µã€‚æŠ›å‡ºå’Œæ•è·å¼‚å¸¸çš„è¿è¡Œæ—¶æˆæœ¬æ˜¯ä¸ç¡®å®šçš„ã€‚è¿™ä½¿å¾—å¼‚å¸¸åœ¨å…·æœ‰ç¡¬å®æ—¶è¦æ±‚çš„æƒ…å†µä¸‹ä¸é€‚ç”¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå…¶ä»–æ›¿ä»£æ–¹æ¡ˆï¼Œå¦‚è¿”å›å¸¦æœ‰è¿”å›å€¼å’Œé”™è¯¯ä»£ç çš„std::pairå¯èƒ½æ›´å¥½ã€‚

### å‡½æ•°å¯¹è±¡å’Œlambdaè¡¨è¾¾å¼

Lambda è¡¨è¾¾å¼ç”Ÿæˆå‡½æ•°å¯¹è±¡ï¼Œè€Œå‡½æ•°å¯¹è±¡æ˜¯å…·æœ‰è°ƒç”¨è¿ç®—ç¬¦ operator() çš„ç±»çš„å®ä¾‹ã€‚è¦ç†è§£ Lambda è¡¨è¾¾å¼çš„ç»„æˆï¼Œå¯ä»¥å°†å…¶è§†ä¸ºå…·æœ‰é™åˆ¶çš„å¸¸è§„ç±»ã€‚å…·ä½“æ¥è¯´ï¼š

* è¯¥ç±»åªåŒ…å«ä¸€ä¸ªæˆå‘˜å‡½æ•°ï¼šoperator()ã€‚
* æ•è·å­å¥æ˜¯ç±»çš„æˆå‘˜å˜é‡å’Œå…¶æ„é€ å‡½æ•°çš„ç»„åˆã€‚

é€šè¿‡å€¼æ•è·çš„ lambda

```cpp
auto is_above = x { return y > x;};

// ç­‰ä»·

class IsAbove {
public: 
    IsAbove(int x) : x{x} {} 
    auto operator()(int y) const {   return y > x; }
private: 
    int x{}; // Value 
};
```

é€šè¿‡å¼•ç”¨æ•è·çš„ lambda

```cpp
auto is_above = &x { return y > x;};

// ç­‰ä»·

class IsAbove {
public: 
    IsAbove(int& x) : x{x} {} 
    auto operator()(int y) const {   return y > x; }
private: 
    int& x; // Reference 
};
```

ç”±äº lambda çš„å·¥ä½œæ–¹å¼å°±åƒä¸€ä¸ªå…·æœ‰æˆå‘˜å˜é‡çš„ç±»ï¼Œå®ƒä¹Ÿå¯ä»¥æ”¹å˜å®ƒä»¬ã€‚ç„¶è€Œï¼Œlambda çš„å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦é»˜è®¤ä¸ºconstï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨mutableå…³é”®å­—æ˜ç¡®æŒ‡å®š lambda å¯ä»¥æ”¹å˜å…¶æˆå‘˜:

```cpp
auto counter_func = [counter = 1]() mutable {
  std::cout << counter++;
};
```

è‡ª C++20 ä»¥æ¥ï¼Œæ²¡æœ‰æ•è·çš„ lambda æ˜¯å¯é»˜è®¤æ„é€ å’Œå¯èµ‹å€¼çš„ã€‚é€šè¿‡ä½¿ç”¨decltypeï¼Œç°åœ¨å¯ä»¥è½»æ¾æ„é€ å…·æœ‰ç›¸åŒç±»å‹çš„ä¸åŒ lambda å¯¹è±¡ï¼š

```cpp
auto x = [] {};   // A lambda without captures
auto y = x;       // Assignable
decltype(y) z;    // Default-constructible
static_assert(std::is_same_v<decltype(x), decltype(y)>); // passes
static_assert(std::is_same_v<decltype(x), decltype(z)>); // passes 
```

è¿™ä»…é€‚ç”¨äºæ²¡æœ‰æ•è·çš„ lambdaã€‚å…·æœ‰æ•è·çš„ lambda æœ‰å®ƒä»¬è‡ªå·±çš„å”¯ä¸€ç±»å‹ã€‚å³ä½¿ä¸¤ä¸ªå…·æœ‰æ•è·çš„ lambda å‡½æ•°æ˜¯å½¼æ­¤çš„å…‹éš†ï¼Œå®ƒä»¬ä»ç„¶å…·æœ‰è‡ªå·±çš„å”¯ä¸€ç±»å‹ã€‚å› æ­¤ï¼Œä¸å¯èƒ½å°†ä¸€ä¸ªå…·æœ‰æ•è·çš„ lambda åˆ†é…ç»™å¦ä¸€ä¸ª lambdaã€‚ 

å³ä½¿æ¯ä¸ªæœ‰çŠ¶æ€çš„ lambda éƒ½æœ‰å…¶è‡ªå·±ç‹¬ç‰¹çš„ç±»å‹ï¼Œä¸€ä¸ªstd::functionç±»å‹å¯ä»¥åŒ…è£…å…±äº«ç›¸åŒç­¾åï¼ˆè¿”å›ç±»å‹å’Œå‚æ•°ï¼‰çš„ lambda

```cpp
class Button {
public: 
  Button(std::function<void(void)> click) : handler_{click} {} 
  auto on_click() const { handler_(); } 
private: 
  std::function<void(void)> handler_{};
}; 

auto create_buttons () { 
  auto beep = Button([counter = 0]() mutable {  
    std::cout << "Beep:" << counter << "! "; 
    ++counter; 
  }); 
  auto bop = Button([] { std::cout << "Bop. "; }); 
  auto silent = Button([] {});
  return std::vector<Button>{beep, bop, silent}; 
} 
```

`std::function`çš„ä¸€äº›æ€§èƒ½æŸå¤±ï¼šé˜»æ­¢å†…è”ä¼˜åŒ–ã€æ•è·å˜é‡çš„åŠ¨æ€åˆ†é…å†…å­˜ï¼ˆå¦‚æœå°† `std::function` åˆ†é…ç»™å¸¦æœ‰æ•è·å˜é‡/å¼•ç”¨çš„ Lambdaï¼Œé‚£ä¹ˆ `std::function` åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹å°†ä½¿ç”¨å †åˆ†é…çš„å†…å­˜æ¥å­˜å‚¨æ•è·çš„å˜é‡ã€‚å¦‚æœæ•è·å˜é‡çš„å¤§å°ä½äºæŸä¸ªé˜ˆå€¼ï¼Œä¸€äº› `std::function` çš„å®ç°å°†ä¸åˆ†é…é¢å¤–çš„å†…å­˜ï¼‰ã€é¢å¤–çš„è¿è¡Œæ—¶è®¡ç®—

ä¸ºäº†ä¼˜åŒ– `std::function` çš„æ€§èƒ½ï¼Œå¯ä»¥è€ƒè™‘ä»¥ä¸‹å‡ ç‚¹ï¼š

* ä¼˜å…ˆä½¿ç”¨å‡½æ•°æŒ‡é’ˆæˆ–å¼•ç”¨ï¼šä»…åœ¨éœ€è¦å°è£…å›è°ƒå‡½æ•°æˆ–å­˜å‚¨ä¸åŒç±»å‹å¯è°ƒç”¨å¯¹è±¡æ—¶ä½¿ç”¨ `std::function`ã€‚
* ä½¿ç”¨ `std::move` è½¬ç§»æ‰€æœ‰æƒï¼šåœ¨ä»ä¸€ä¸ªå®¹å™¨ç§»åŠ¨åˆ°å¦ä¸€ä¸ªå®¹å™¨æ—¶ï¼Œä½¿ç”¨ `std::move` æ¥å‡å°‘ä¸å¿…è¦çš„å¤åˆ¶å¼€é”€ã€‚
* é¿å…é¢‘ç¹å¤åˆ¶ `std::function` å¯¹è±¡ï¼šå°¤å…¶æ˜¯é‚£äº›å°è£…äº†å¤§é‡çŠ¶æ€çš„å¯è°ƒç”¨å¯¹è±¡ã€‚
* ç¼–è¯‘å™¨ä¼˜åŒ–ï¼šç¡®ä¿åœ¨ç¼–è¯‘æ—¶æ‰“å¼€é€‚å½“çš„ä¼˜åŒ–çº§åˆ«ï¼Œä¾‹å¦‚ä½¿ç”¨ `-O2` æˆ– `-O3`

é€šç”¨lambdaï¼š

```cpp
auto lambda = [](auto x, auto y) {
    return x + y;
};

// é€šç”¨ Lambda çš„è¡Œä¸ºç±»ä¼¼äºæ¨¡æ¿å‡½æ•°ã€‚ç¼–è¯‘å™¨ä¼šä¸ºæ¯ç§ä¸åŒçš„å‚æ•°ç±»å‹ç”Ÿæˆå¯¹åº”çš„å®ä¾‹

// ç¼–è¯‘å™¨ä¼šå°†å…¶è½¬æ¢ä¸ºç±»ä¼¼ä»¥ä¸‹çš„ä»£ç ï¼š
struct AnonymousLambda {
    template<typename T1, typename T2>
    auto operator()(T1 x, T2 y) const {
        return x + y;
    }
};

// C++20 è¿›ä¸€æ­¥æ‰©å±•äº† Lambda çš„åŠŸèƒ½ï¼Œå…è®¸æ˜¾å¼ä½¿ç”¨æ¨¡æ¿è¯­æ³•å®šä¹‰ Lambdaã€‚ä¾‹å¦‚ï¼š
auto lambda = []<typename T>(T x, T y) {
    return x + y;
};
```

## 3. åˆ†æå’Œæµ‹é‡æ€§èƒ½

**æ‘Šé”€æ—¶é—´å¤æ‚åº¦**ï¼šæ‘Šé”€æ—¶é—´å¤æ‚åº¦å…³æ³¨çš„æ˜¯ä¸€ç³»åˆ—æ“ä½œçš„æ€»æ—¶é—´ï¼Œç„¶åå°†å…¶å¹³å‡åˆ†é…åˆ°æ¯ä¸ªæ“ä½œä¸Šã€‚å³ä½¿æŸäº›æ“ä½œçš„æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ï¼Œåªè¦è¿™äº›æ“ä½œçš„å‘ç”Ÿé¢‘ç‡è¾ƒä½ï¼Œæ•´ä½“å¹³å‡æ€§èƒ½ä»ç„¶å¯ä»¥å¾ˆå¥½ã€‚

**å¦‚ä½•ä¼˜åŒ–**ï¼šæ˜ç¡®ç›®æ ‡ã€æµ‹é‡ã€æ‰¾å‡ºç“¶é¢ˆã€åšå‡ºåˆç†çŒœæµ‹ã€ä¼˜åŒ–ã€è¯„ä¼°ã€é‡æ„

**æ€§èƒ½ç‰¹æ€§**ï¼šå»¶è¿Ÿ/å“åº”æ—¶é—´ã€ååé‡ã€IO boundã€CPU boundã€åŠŸè€—

**æ’æ¡©åˆ†æ**ï¼šå‘ç¨‹åºä¸­æ’å…¥ä»£ç ä»¥ä¾¿åˆ†æï¼Œä»¥æ”¶é›†å…³äºæ¯ä¸ªå‡½æ•°è¢«æ‰§è¡Œé¢‘ç‡çš„ä¿¡æ¯ã€‚

**é‡‡æ ·åˆ†æ**ï¼šé‡‡æ ·åˆ†æå™¨é€šè¿‡åœ¨å‡åŒ€é—´éš”ï¼ˆé€šå¸¸ä¸ºæ¯ 10 æ¯«ç§’ï¼‰æŸ¥çœ‹è¿è¡Œç¨‹åºçš„çŠ¶æ€æ¥åˆ›å»ºæ¦‚è¦ã€‚

åœ¨æ¦‚å¿µä¸Šï¼Œé‡‡æ ·åˆ†æå™¨ä»¥å‡åŒ€çš„æ—¶é—´é—´éš”å­˜å‚¨è°ƒç”¨å †æ ˆçš„æ ·æœ¬ã€‚å®ƒæ£€æµ‹å½“å‰åœ¨ CPU ä¸Šè¿è¡Œçš„å†…å®¹ã€‚çº¯é‡‡æ ·åˆ†æå™¨é€šå¸¸åªæ£€æµ‹å½“å‰åœ¨è¿è¡ŒçŠ¶æ€çš„çº¿ç¨‹ä¸­æ‰§è¡Œçš„å‡½æ•°ï¼Œå› ä¸ºä¼‘çœ çº¿ç¨‹ä¸ä¼šè¢«è°ƒåº¦åˆ° CPU ä¸Šã€‚è¿™æ„å‘³ç€å¦‚æœä¸€ä¸ªå‡½æ•°æ­£åœ¨ç­‰å¾…å¯¼è‡´çº¿ç¨‹ä¼‘çœ çš„é”ï¼Œé‚£ä¹ˆè¿™æ®µæ—¶é—´ä¸ä¼šæ˜¾ç¤ºåœ¨æ—¶é—´æ¦‚è¦ä¸­ã€‚è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºæ‚¨çš„ç“¶é¢ˆå¯èƒ½æ˜¯ç”±çº¿ç¨‹åŒæ­¥å¼•èµ·çš„ï¼Œè¿™å¯èƒ½å¯¹é‡‡æ ·åˆ†æå™¨æ˜¯ä¸å¯è§çš„ã€‚

**MicroBenchmarkï¼ˆå¾®åŸºå‡†æµ‹è¯•ï¼‰** ï¼šæ‰¾åˆ°éœ€è¦è°ƒæ•´çš„çƒ­ç‚¹ï¼Œæœ€å¥½ä½¿ç”¨åˆ†æå™¨ï¼›å°†å…¶ä¸å…¶ä½™ä»£ç åˆ†ç¦»å¹¶åˆ›å»ºä¸€ä¸ªå­¤ç«‹çš„å¾®åŸºå‡†æµ‹è¯•ï¼›ä¼˜åŒ–å¾®åŸºå‡†æµ‹è¯•ã€‚ä½¿ç”¨åŸºå‡†æµ‹è¯•æ¡†æ¶åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­æµ‹è¯•å’Œè¯„ä¼°ä»£ç ï¼›å°†æ–°ä¼˜åŒ–çš„ä»£ç é›†æˆåˆ°ç¨‹åºä¸­ï¼Œç„¶åé‡æ–°æµ‹é‡ï¼Œçœ‹çœ‹å½“ä»£ç åœ¨æ›´å¤§çš„ä¸Šä¸‹æ–‡ä¸­è¿è¡Œæ—¶ï¼Œä¼˜åŒ–æ˜¯å¦ç›¸å…³ã€‚

**MicroBenchmarkçš„é™·é˜±**ï¼šç¼–è¯‘å™¨å¯èƒ½ä¼šä»¥ä¸åŒäºåœ¨å®Œæ•´ç¨‹åºä¸­ä¼˜åŒ–çš„æ–¹å¼æ¥ä¼˜åŒ–å­¤ç«‹çš„ä»£ç ï¼›åœ¨åŸºå‡†æµ‹è¯•ä¸­æœªä½¿ç”¨çš„è¿”å›å€¼å¯èƒ½ä¼šä½¿ç¼–è¯‘å™¨åˆ é™¤æˆ‘ä»¬è¯•å›¾æµ‹é‡çš„å‡½æ•°ï¼›åœ¨å¾®åŸºå‡†æµ‹è¯•ä¸­æä¾›çš„é™æ€æµ‹è¯•æ•°æ®å¯èƒ½ä¼šä½¿ç¼–è¯‘å™¨åœ¨ä¼˜åŒ–ä»£ç æ—¶è·å¾—ä¸åˆ‡å®é™…çš„ä¼˜åŠ¿ï¼ˆæ¯”å¦‚ç¡®å®šçš„å¾ªç¯æ¬¡æ•°å¯¼è‡´å‘é‡åŒ–ä¼˜åŒ–ï¼‰

## 4. æ•°æ®ç»“æ„

ç¼“å­˜ã€ç¼“å­˜å»¶è¿Ÿã€æ—¶é—´å±€éƒ¨æ€§ã€ç©ºé—´å±€éƒ¨æ€§ã€ç¼“å­˜æŠ–åŠ¨

**åºåˆ—å®¹å™¨**

`std::vector`ä½¿ç”¨`std::move_if_noexcept`æ¥ç¡®å®šå¯¹è±¡æ˜¯åº”è¯¥è¢«å¤åˆ¶è¿˜æ˜¯ç§»åŠ¨ã€‚

ä½œä¸ºåŠ¨æ€å¤§å°å‘é‡çš„æ›¿ä»£ï¼Œæ ‡å‡†åº“è¿˜æä¾›äº†ä¸€ä¸ªåä¸º`std::array`çš„å›ºå®šå¤§å°ç‰ˆæœ¬ï¼Œå®ƒé€šè¿‡ä½¿ç”¨å †æ ˆè€Œä¸æ˜¯è‡ªç”±å­˜å‚¨æ¥ç®¡ç†å…¶å…ƒç´ ã€‚æ•°ç»„çš„å¤§å°æ˜¯åœ¨ç¼–è¯‘æ—¶æŒ‡å®šçš„æ¨¡æ¿å‚æ•°ï¼Œè¿™æ„å‘³ç€å¤§å°å’Œç±»å‹å…ƒç´ æˆä¸ºå…·ä½“ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚

`std::deque`é€šå¸¸å®ç°ä¸ºä¸€ç»„å›ºå®šå¤§å°çš„æ•°ç»„ï¼Œè¿™ä½¿å¾—å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…é€šè¿‡å®ƒä»¬çš„ç´¢å¼•è®¿é—®å…ƒç´ ã€‚

`std::list`æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œæ„å‘³ç€æ¯ä¸ªå…ƒç´ éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªæŒ‡å‘å‰ä¸€ä¸ªå…ƒç´ çš„é“¾æ¥ã€‚è¿™ä½¿å¾—å¯ä»¥å‘å‰å’Œå‘åéå†åˆ—è¡¨ã€‚è¿˜æœ‰ä¸€ä¸ªåä¸º`std::forward_list`çš„å•å‘é“¾è¡¨ã€‚

**å…³è”å®¹å™¨**

æœ‰åºå…³è”å®¹å™¨ï¼šåŸºäºæ ‘ï¼Œstd::setã€std::mapã€std::multisetå’Œstd::multimapã€‚

æ— åºå…³è”å®¹å™¨ï¼šåŸºäºå“ˆå¸Œè¡¨ï¼Œstd::unordered_setã€std::unordered_mapã€std::unordered_multisetå’Œstd::unordered_multimap

**å®¹å™¨é€‚é…å™¨**

æ ‡å‡†åº“ä¸­æœ‰ä¸‰ç§å®¹å™¨é€‚é…å™¨ï¼šstd::stackã€std::queueå’Œstd::priority_queueã€‚å®¹å™¨é€‚é…å™¨ä¸åºåˆ—å®¹å™¨å’Œå…³è”å®¹å™¨éå¸¸ä¸åŒï¼Œå› ä¸ºå®ƒä»¬ä»£è¡¨å¯ä»¥ç”±åº•å±‚åºåˆ—å®¹å™¨å®ç°çš„æŠ½è±¡æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå †æ ˆæ˜¯ä¸€ä¸ªåè¿›å…ˆå‡ºï¼ˆLIFOï¼‰æ•°æ®ç»“æ„ï¼Œæ”¯æŒåœ¨å †æ ˆé¡¶éƒ¨è¿›è¡Œæ¨é€å’Œå¼¹å‡ºï¼Œå¯ä»¥ä½¿ç”¨vectorã€listã€dequeæˆ–ä»»ä½•å…¶ä»–æ”¯æŒback()ã€push_back()å’Œpop_back()çš„è‡ªå®šä¹‰åºåˆ—å®¹å™¨æ¥å®ç°ã€‚é˜Ÿåˆ—ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå®ƒæ˜¯ä¸€ä¸ªå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰æ•°æ®ç»“æ„ï¼Œä»¥åŠpriority_queueã€‚

**è§†å›¾**

C++17 ä¸­çš„`std::string_view`å’Œ C++20 ä¸­å¼•å…¥çš„`std::span`ã€‚

`std::span`æŒ‡å‘çš„å†…å­˜æ˜¯å¯å˜çš„ï¼Œè€Œ`std::string_view`æ€»æ˜¯æŒ‡å‘å¸¸é‡å†…å­˜ã€‚`std::string_view`è¿˜åŒ…å«ç‰¹å®šäºå­—ç¬¦ä¸²çš„å‡½æ•°ï¼Œå¦‚`hash()`å’Œ`substr()`ï¼Œè¿™è‡ªç„¶ä¸æ˜¯`std::span`çš„ä¸€éƒ¨åˆ†ã€‚æœ€åï¼Œåœ¨`std::span`ä¸­æ²¡æœ‰`compare()`å‡½æ•°ï¼Œå› æ­¤ä¸å¯èƒ½ç›´æ¥åœ¨`std::span`å¯¹è±¡ä¸Šä½¿ç”¨æ¯”è¾ƒè¿ç®—ç¬¦ã€‚

**æ€§èƒ½è€ƒè™‘**

é€‰æ‹©åˆé€‚çš„å®¹å™¨ã€ä½¿ç”¨åˆé€‚çš„API

**å¹¶è¡Œæ•°ç»„**ï¼šï¼ˆParallel Arraysï¼‰æ˜¯æŒ‡ä¸€ç»„å…·æœ‰ç›¸åŒé•¿åº¦çš„æ•°ç»„ï¼Œè¿™äº›æ•°ç»„ä¸­çš„å…ƒç´ åœ¨ç›¸åŒç´¢å¼•ä½ç½®ä¸Šå­˜åœ¨é€»è¾‘å…³è”ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªæ•°ç»„ä»£è¡¨å¯¹è±¡çš„ä¸€ä¸ªä¸åŒå±æ€§ï¼Œè€Œç›¸åŒç´¢å¼•å¤„çš„å…ƒç´ ç»„åˆèµ·æ¥æè¿°ä¸€ä¸ªå®Œæ•´çš„å®ä½“ã€‚

ä¼˜åŠ¿

* ç®€å•æ€§ï¼šå®ç°èµ·æ¥éå¸¸ç›´è§‚å’Œç®€å•ï¼Œä¸éœ€è¦å®šä¹‰å¤æ‚çš„ç±»æˆ–æ•°æ®ç»“æ„ã€‚å¯¹äºç®€å•çš„åº”ç”¨åœºæ™¯ï¼Œä½¿ç”¨å¹¶è¡Œæ•°ç»„å¯ä»¥å¿«é€Ÿåœ°å­˜å‚¨å’Œè®¿é—®ç›¸å…³æ•°æ®ã€‚
* å†…å­˜æ•ˆç‡ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¹¶è¡Œæ•°ç»„å¯ä»¥æ¯”ä½¿ç”¨å¯¹è±¡æ•°ç»„æ›´èŠ‚çœå†…å­˜ã€‚å› ä¸ºå¯¹è±¡æ•°ç»„é€šå¸¸ä¼šåŒ…å«é¢å¤–çš„å…ƒæ•°æ®ï¼ˆå¦‚å¯¹è±¡å¤´ï¼‰ï¼Œè€Œå¹¶è¡Œæ•°ç»„åªå­˜å‚¨å®é™…çš„æ•°æ®ã€‚
* è®¿é—®é€Ÿåº¦ï¼šç”±äºæ•°ç»„æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œå¯¹å¹¶è¡Œæ•°ç»„çš„éšæœºè®¿é—®é€Ÿåº¦è¾ƒå¿«ã€‚å¯ä»¥ç›´æ¥é€šè¿‡ç´¢å¼•è®¿é—®æ¯ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(1)

åŠ£åŠ¿

* å¯ç»´æŠ¤æ€§å·®ï¼šéšç€æ•°æ®è§„æ¨¡çš„å¢å¤§å’Œéœ€æ±‚çš„å˜åŒ–ï¼Œå¹¶è¡Œæ•°ç»„çš„ä»£ç ä¼šå˜å¾—éš¾ä»¥ç»´æŠ¤ã€‚å¦‚æœéœ€è¦æ·»åŠ æ–°çš„å±æ€§ï¼Œå°±éœ€è¦åŒæ—¶ä¿®æ”¹å¤šä¸ªæ•°ç»„ï¼Œå®¹æ˜“å¼•å…¥é”™è¯¯ã€‚
* ç¼ºä¹å°è£…æ€§ï¼šå¹¶è¡Œæ•°ç»„æ²¡æœ‰å°†ç›¸å…³çš„æ•°æ®å°è£…åœ¨ä¸€èµ·ï¼Œæ•°æ®çš„é€»è¾‘å…³ç³»ä¸å¤Ÿæ¸…æ™°ã€‚è¿™ä½¿å¾—ä»£ç çš„å¯è¯»æ€§å’Œå¯ç†è§£æ€§é™ä½ï¼Œä¸åˆ©äºå›¢é˜Ÿåä½œå’Œä»£ç çš„é•¿æœŸç»´æŠ¤ã€‚
* å®¹æ˜“å‡ºé”™ï¼šç”±äºéœ€è¦æ‰‹åŠ¨ç®¡ç†å¤šä¸ªæ•°ç»„çš„ç´¢å¼•ï¼Œå®¹æ˜“å‡ºç°ç´¢å¼•ä¸ä¸€è‡´çš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œåœ¨åˆ é™¤æˆ–æ’å…¥å…ƒç´ æ—¶ï¼Œå¦‚æœåªä¿®æ”¹äº†éƒ¨åˆ†æ•°ç»„çš„ç´¢å¼•ï¼Œå°±ä¼šå¯¼è‡´æ•°æ®ä¸ä¸€è‡´ã€‚
* æ‰©å±•æ€§æœ‰é™ï¼šå½“æ•°æ®çš„ç»“æ„å˜å¾—å¤æ‚æ—¶ï¼Œå¹¶è¡Œæ•°ç»„å¾ˆéš¾è¿›è¡Œæ‰©å±•ã€‚ä¾‹å¦‚ï¼Œå¦‚æœéœ€è¦å¤„ç†åµŒå¥—çš„æ•°æ®ç»“æ„æˆ–å¤æ‚çš„å…³ç³»ï¼Œä½¿ç”¨å¹¶è¡Œæ•°ç»„ä¼šå˜å¾—éå¸¸å›°éš¾ã€‚

## 5. ç®—æ³•

C++20 é€šè¿‡å¼•å…¥ Ranges åº“å’Œ C++Concept çš„è¯­è¨€ç‰¹æ€§å¯¹ç®—æ³•åº“è¿›è¡Œäº†é‡å¤§æ”¹å˜ã€‚

**è¿­ä»£å™¨å’ŒèŒƒå›´**

è¿­ä»£å™¨æ˜¯æ•°æ®ç»“æ„å’Œç®—æ³•ä¹‹é—´çš„ç²˜åˆå‰‚ã€‚è¿­ä»£å™¨æŠ½è±¡æ ¹æœ¬ä¸æ˜¯ C++ç‹¬æœ‰çš„æ¦‚å¿µï¼Œè€Œæ˜¯å­˜åœ¨äºå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ã€‚C++å®ç°è¿­ä»£å™¨æ¦‚å¿µçš„ä¸åŒä¹‹å¤„åœ¨äºï¼ŒC++æ¨¡ä»¿äº†åŸå§‹å†…å­˜æŒ‡é’ˆçš„è¯­æ³•ã€‚

èŒƒå›´æ˜¯æŒ‡æˆ‘ä»¬åœ¨å¼•ç”¨ä¸€ç³»åˆ—å…ƒç´ æ—¶ä½¿ç”¨çš„è¿­ä»£å™¨-å“¨å…µå¯¹çš„æ›¿ä»£å“ã€‚`<range>`å¤´æ–‡ä»¶åŒ…å«äº†å®šä¹‰ä¸åŒç§ç±»èŒƒå›´è¦æ±‚çš„å¤šä¸ªæ¦‚å¿µï¼Œä¾‹å¦‚input_rangeï¼Œrandom_access_rangeç­‰ç­‰ã€‚å¦‚ä¸‹ Concept çº¦æŸæ„å‘³ç€ä»»ä½•æš´éœ²begin()å’Œend()å‡½æ•°çš„ç±»å‹éƒ½è¢«è®¤ä¸ºæ˜¯èŒƒå›´

```cpp
template<class T>
concept range = requires(T& t) {
  ranges::begin(t);
  ranges::end(t);
}; 
```

ä¸ºäº†é€‚é…ç®—æ³•åœºæ™¯ï¼Œè¿­ä»£å™¨è¢«è®¾è®¡äº†å…­ç§ç±»å‹ï¼š

* `std::input_iterator`ï¼šæ”¯æŒåªè¯»å’Œå‘å‰ç§»åŠ¨ï¼ˆä¸€æ¬¡ï¼‰ã€‚å¦‚`std::count()`å¯ä»¥ä½¿ç”¨è¾“å…¥è¿­ä»£å™¨

* `std::output_iterator`ï¼šæ”¯æŒåªå†™å’Œå‘å‰ç§»åŠ¨ï¼ˆä¸€æ¬¡ï¼‰ã€‚è¯·æ³¨æ„ï¼Œè¾“å‡ºè¿­ä»£å™¨åªèƒ½å†™å…¥ï¼Œä¸èƒ½è¯»å–ã€‚`std::ostream_iterator`æ˜¯è¾“å‡ºè¿­ä»£å™¨çš„ä¸€ä¸ªä¾‹å­ã€‚

* `std::forward_iterator`ï¼šæ”¯æŒè¯»å–ï¼Œå†™å…¥å’Œå‘å‰ç§»åŠ¨ã€‚å½“å‰ä½ç½®çš„å€¼å¯ä»¥å¤šæ¬¡è¯»å–æˆ–å†™å…¥ã€‚

* `std::bidirectional_iterator`ï¼šæ”¯æŒè¯»å–ï¼Œå†™å…¥ï¼Œå‘å‰ç§»åŠ¨å’Œå‘åç§»åŠ¨ã€‚

* `std::random_access_iterator`ï¼šæ”¯æŒè¯»å–ï¼Œå†™å…¥ï¼Œå‘å‰ç§»åŠ¨ï¼Œå‘åç§»åŠ¨å’Œåœ¨å¸¸æ•°æ—¶é—´å†…è·³è½¬åˆ°ä»»æ„ä½ç½®ã€‚

* `std::contiguous_iterator`ï¼šä¸éšæœºè®¿é—®è¿­ä»£å™¨ç›¸åŒï¼Œä½†ä¹Ÿä¿è¯åº•å±‚æ•°æ®æ˜¯è¿ç»­çš„å†…å­˜å—ï¼Œä¾‹å¦‚`std::string`ï¼Œ`std::vector`ï¼Œ`std::array`ï¼Œ`std::span`å’Œï¼ˆå¾ˆå°‘ä½¿ç”¨çš„ï¼‰`std::valarray`

### å®šä¹‰åœ¨<algorithm>ä¸­çš„æ ‡å‡†ç®—æ³•é€šå¸¸å…·æœ‰å¦‚ä¸‹ç‰¹æ€§ï¼š

#### ç®—æ³•ä¸ä¼šæ”¹å˜å®¹å™¨çš„å¤§å°(Functions from <algorithm> can only modify the elements in a specified range)ã€‚

`std::remove()`æˆ–`std::unique()`å®é™…ä¸Šå¹¶ä¸ä¼šä»å®¹å™¨ä¸­åˆ é™¤å…ƒç´ ï¼ˆå°½ç®¡å®ƒä»¬çš„åå­—æ˜¯è¿™æ ·ï¼‰ã€‚ç›¸åï¼Œå®ƒä»¬å°†åº”è¯¥ä¿ç•™çš„å…ƒç´ ç§»åŠ¨åˆ°å®¹å™¨çš„å‰é¢ï¼Œç„¶åè¿”å›ä¸€ä¸ªæ ‡è®°ï¼Œå®šä¹‰äº†å…ƒç´ çš„æœ‰æ•ˆèŒƒå›´çš„æ–°ç»“å°¾

#### å¸¦æœ‰è¾“å‡ºçš„ç®—æ³•éœ€è¦é¢„é€‰åˆ†é…ç›®æ ‡å®¹å™¨ç©ºé—´(Algorithms with output require allocated data)

```cpp
const auto square_func = [](int x) { return x * x; };
const auto v = std::vector{1, 2, 3, 4};
auto squared = std::vector<int>{};
std::ranges::transform(v, squared.begin(), square_func); 
```

è¿™æ®µä»£ç åœ¨é€»è¾‘ä¸Šå­˜åœ¨ä¸€ä¸ªæ½œåœ¨é—®é¢˜ï¼Œå…·ä½“å¦‚ä¸‹ï¼š`std::ranges::transform` æ˜¯ C++20 å¼•å…¥çš„ç®—æ³•ï¼Œç”¨äºå¯¹ä¸€ä¸ªèŒƒå›´å†…çš„å…ƒç´ è¿›è¡Œå˜æ¢æ“ä½œï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°å¦ä¸€ä¸ªèŒƒå›´ä¸­ã€‚å®ƒçš„åŸºæœ¬ç”¨æ³•æ˜¯ï¼š`std::ranges::transform(input_range, output_iterator, unary_op);`

`squared` è¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªç©ºçš„ `std::vector<int>`ï¼Œå› æ­¤ `squared.begin()` æ˜¯ä¸€ä¸ªæ— æ•ˆçš„è¿­ä»£å™¨ã€‚`std::ranges::transform` ä¼šå°è¯•å°†ç»“æœå­˜å‚¨åˆ° `squared` ä¸­ï¼Œä½†ç”±äº `squared` çš„å¤§å°ä¸º 0ï¼Œè¿™ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼ˆUndefined Behaviorï¼ŒUBï¼‰ã€‚å…·ä½“è¡¨ç°å¯èƒ½æ˜¯ç¨‹åºå´©æºƒã€æ•°æ®æŸåæˆ–å…¶ä»–ä¸å¯é¢„æµ‹çš„è¡Œä¸ºã€‚

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥é‡‡ç”¨ä»¥ä¸‹æ–¹æ³•ä¹‹ä¸€ï¼š

```cpp
// åœ¨è°ƒç”¨ `std::ranges::transform` ä¹‹å‰ï¼Œä¸º `squared` åˆ†é…è¶³å¤Ÿçš„ç©ºé—´ï¼Œä½¿å…¶å¤§å°ä¸è¾“å…¥èŒƒå›´ `v` ä¸€è‡´
squared.resize(v.size());
std::ranges::transform(v, squared.begin(), square_func);
```

æˆ–è€…

```cpp
// ä½¿ç”¨ `std::back_inserter` æ¥è‡ªåŠ¨æ‰©å±• `squared` çš„å¤§å°ï¼š
std::ranges::transform(v, std::back_inserter(squared), square_func);
```

#### ç®—æ³•é»˜è®¤ä½¿ç”¨`operator==()`å’Œ`operator()<`

#### å—é™ç®—æ³•ä½¿ç”¨æŠ•å½±

åœ¨ C++ ä¸­ï¼Œ**å—é™ç®—æ³•ï¼ˆConstrained Algorithmsï¼‰** å’Œ **æŠ•å½±ï¼ˆProjectionï¼‰** æ˜¯ C++20 æ ‡å‡†å¼•å…¥çš„ä¸¤ä¸ªé‡è¦æ¦‚å¿µï¼Œå®ƒä»¬ä¸èŒƒå›´ï¼ˆRangesï¼‰åº“ç´§å¯†ç›¸å…³ï¼Œç”¨äºæé«˜ç®—æ³•çš„çµæ´»æ€§å’Œè¡¨è¾¾èƒ½åŠ›ã€‚

å—é™ç®—æ³•æ˜¯ C++20 ä¸­å¯¹æ ‡å‡†ç®—æ³•åº“çš„æ”¹è¿›ã€‚åœ¨ C++20 ä¹‹å‰ï¼Œæ ‡å‡†ç®—æ³•åº“ä¸­çš„ç®—æ³•ï¼ˆå¦‚ `std::sort`ã€`std::find` ç­‰ï¼‰é€šå¸¸åªæ¥å—ç‰¹å®šç±»å‹çš„è¿­ä»£å™¨æˆ–å®¹å™¨ã€‚ç„¶è€Œï¼ŒC++20 å¼•å…¥äº† **èŒƒå›´ï¼ˆRangesï¼‰**ï¼Œå…è®¸ç®—æ³•ç›´æ¥ä½œç”¨äºèŒƒå›´å¯¹è±¡ï¼Œè€Œä¸ä»…ä»…æ˜¯è¿­ä»£å™¨å¯¹ã€‚å—é™ç®—æ³•é€šè¿‡æ¨¡æ¿çº¦æŸï¼ˆConceptsï¼‰æ¥é™åˆ¶ç®—æ³•çš„è¾“å…¥ï¼Œä½¿å…¶èƒ½å¤Ÿæ›´è‡ªç„¶åœ°ä¸èŒƒå›´åº“ç»“åˆã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å—é™ç®—æ³•çš„ç¤ºä¾‹ï¼š

```cpp
// `std::ranges::sort` æ˜¯ä¸€ä¸ªå—é™ç®—æ³•ï¼Œå®ƒç›´æ¥ä½œç”¨äº `std::vector<int>` çš„èŒƒå›´å¯¹è±¡ `v`ï¼Œè€Œä¸éœ€è¦æ˜¾å¼åœ°ä¼ é€’è¿­ä»£å™¨å¯¹
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6};
    std::ranges::sort(v); // å—é™ç®—æ³•ï¼Œç›´æ¥ä½œç”¨äºèŒƒå›´
    for (const auto& x : v) {
        std::cout << x << " ";
    }
    return 0;
}
```

æŠ•å½±æ˜¯ C++20 èŒƒå›´åº“ä¸­å¼•å…¥çš„ä¸€ä¸ªæ¦‚å¿µï¼Œç”¨äºåœ¨ç®—æ³•ä¸­å¯¹èŒƒå›´çš„å…ƒç´ è¿›è¡Œè½¬æ¢æˆ–æ˜ å°„ã€‚æŠ•å½±å…è®¸ç®—æ³•åœ¨å¤„ç†å…ƒç´ ä¹‹å‰ï¼Œå…ˆå¯¹å…ƒç´ è¿›è¡ŒæŸç§æ“ä½œï¼Œä»è€Œå®ç°æ›´çµæ´»çš„ç®—æ³•è¡Œä¸ºã€‚

æŠ•å½±é€šå¸¸é€šè¿‡ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼ˆå¦‚å‡½æ•°ã€lambda è¡¨è¾¾å¼æˆ–å‡½æ•°å¯¹è±¡ï¼‰æ¥å®ç°ã€‚åœ¨è°ƒç”¨ç®—æ³•æ—¶ï¼Œå¯ä»¥é€šè¿‡ `std::ranges::views::transform` æˆ–ç›´æ¥ä¼ é€’æŠ•å½±å‡½æ•°æ¥æŒ‡å®šæŠ•å½±æ“ä½œã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨æŠ•å½±çš„ç¤ºä¾‹ï¼š

```cpp
// `std::views::transform` æ˜¯ä¸€ä¸ªæŠ•å½±æ“ä½œï¼Œå®ƒå°† `v` ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²æ˜ å°„ä¸ºå…¶é•¿åº¦ã€‚æŠ•å½±çš„ç»“æœæ˜¯ä¸€ä¸ªæ–°çš„èŒƒå›´å¯¹è±¡ `lengths`ï¼ŒåŒ…å«æ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<std::string> v = {"apple", "banana", "cherry"};
    auto lengths = v | std::views::transform([](const std::string& s) { return s.length(); });
    for (const auto& len : lengths) {
        std::cout << len << " ";
    }
    return 0;
}
```

æŠ•å½±ä¹Ÿå¯ä»¥ç›´æ¥åœ¨å—é™ç®—æ³•ä¸­ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œ`std::ranges::max` ç®—æ³•å¯ä»¥é€šè¿‡æŠ•å½±æ¥æŒ‡å®šæ¯”è¾ƒçš„ä¾æ®ï¼š

```cpp
// `std::ranges::max` çš„ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæŠ•å½±å‡½æ•°ï¼Œç”¨äºæŒ‡å®šæ¯”è¾ƒçš„ä¾æ®ï¼ˆå³å­—ç¬¦ä¸²çš„é•¿åº¦ï¼‰
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<std::string> v = {"apple", "banana", "cherry"};
    auto longest = std::ranges::max(v, {}, [](const std::string& s) { return s.length(); });
    std::cout << "Longest string: " << longest << std::endl;
    return 0;
}
```

- **å—é™ç®—æ³•**ï¼šé€šè¿‡æ¨¡æ¿çº¦æŸå’ŒèŒƒå›´æ”¯æŒï¼Œä½¿ç®—æ³•æ›´åŠ çµæ´»å’Œç±»å‹å®‰å…¨ã€‚
- **æŠ•å½±**ï¼šå…è®¸åœ¨ç®—æ³•ä¸­å¯¹èŒƒå›´çš„å…ƒç´ è¿›è¡Œè½¬æ¢æˆ–æ˜ å°„ï¼Œä»è€Œå®ç°æ›´çµæ´»çš„ç®—æ³•è¡Œä¸ºã€‚
- **ç»“åˆä½¿ç”¨**ï¼šå—é™ç®—æ³•å’ŒæŠ•å½±å¯ä»¥ç»“åˆä½¿ç”¨ï¼Œä»¥å®ç°æ›´å¼ºå¤§çš„åŠŸèƒ½ï¼Œæé«˜ä»£ç çš„å¯è¯»æ€§å’Œçµæ´»æ€§ã€‚

#### ç®—æ³•è¦æ±‚`Move`æ“ä½œä¸èƒ½æŠ›å‡ºå¼‚å¸¸

#### ç®—æ³•å…·æœ‰å¤æ‚æ€§ä¿è¯

å®ƒä»¬æ—¢ä¸åˆ†é…å†…å­˜ï¼Œä¹Ÿä¸å…·æœ‰é«˜äºO(n log n)çš„æ—¶é—´å¤æ‚åº¦

Note the exceptions of `stable_sort()`, `inplace_merge()`, and `stable_partition()`. Many implementations tend to temporarily allocate memory during these operations

#### ç®—æ³•çš„æ€§èƒ½ä¸Cåº“å‡½æ•°çš„ç­‰ä»·ä¸€æ ·å¥½

æ ‡å‡† C åº“é…å¤‡äº†è®¸å¤šä½çº§ç®—æ³•ï¼ŒåŒ…æ‹¬`memcpy()`ã€`memmove()`ã€`memcmp()`å’Œ`memset()`ã€‚æœ‰æ—¶äººä»¬ä½¿ç”¨è¿™äº›å‡½æ•°è€Œä¸æ˜¯æ ‡å‡†ç®—æ³•åº“ä¸­çš„ç­‰ä»·ç‰©ã€‚åŸå› æ˜¯äººä»¬å€¾å‘äºç›¸ä¿¡ C åº“å‡½æ•°æ›´å¿«ï¼Œå› æ­¤æ¥å—ç±»å‹å®‰å…¨çš„æŠ˜è¡·ã€‚

è¿™å¯¹äºç°ä»£æ ‡å‡†åº“å®ç°æ¥è¯´æ˜¯ä¸æ­£ç¡®çš„ï¼›ç­‰ä»·ç®—æ³•`std::copy()`ã€`std::equal()`å’Œ`std::fill()`åœ¨å¯èƒ½çš„æƒ…å†µä¸‹ä¼šä½¿ç”¨è¿™äº›ä½çº§ C å‡½æ•°ï¼›å› æ­¤ï¼Œå®ƒä»¬æ—¢æä¾›æ€§èƒ½åˆæä¾›ç±»å‹å®‰å…¨ã€‚

å½“ç„¶ï¼Œä¹Ÿè®¸ä¼šæœ‰ä¾‹å¤–æƒ…å†µï¼ŒC++ç¼–è¯‘å™¨æ— æ³•æ£€æµ‹åˆ°å¯ä»¥å®‰å…¨åœ°ä½¿ç”¨ä½çº§ C å‡½æ•°çš„æƒ…å†µã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªç±»å‹ä¸æ˜¯å¹³å‡¡å¯å¤åˆ¶çš„ï¼Œstd::copy()å°±ä¸èƒ½ä½¿ç”¨memcpy()ã€‚ä½†è¿™æ˜¯æœ‰å……åˆ†ç†ç”±çš„ï¼›å¸Œæœ›ä¸€ä¸ªä¸æ˜¯å¹³å‡¡å¯å¤åˆ¶çš„ç±»çš„ä½œè€…æœ‰å……åˆ†çš„ç†ç”±ä»¥è¿™ç§æ–¹å¼è®¾è®¡ç±»ï¼Œæˆ‘ä»¬ï¼ˆæˆ–ç¼–è¯‘å™¨ï¼‰ä¸åº”è¯¥å¿½è§†è¿™ä¸€ç‚¹ï¼Œè€Œä¸è°ƒç”¨é€‚å½“çš„æ„é€ å‡½æ•°ã€‚

æœ‰æ—¶ï¼ŒC++ç®—æ³•åº“ä¸­çš„å‡½æ•°ç”šè‡³æ¯”å®ƒä»¬çš„ C åº“ç­‰æ•ˆå‡½æ•°è¡¨ç°å¾—æ›´å¥½ã€‚æœ€çªå‡ºçš„ä¾‹å­æ˜¯`std::sort()`ä¸ C åº“ä¸­çš„`qsort()`ã€‚`std::sort()`å’Œ`qsort()`ä¹‹é—´çš„ä¸€ä¸ªé‡å¤§åŒºåˆ«æ˜¯ï¼Œ`qsort()`æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè€Œ`std::sort()`æ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ã€‚å½“`qsort()`è°ƒç”¨æ¯”è¾ƒå‡½æ•°æ—¶ï¼Œç”±äºå®ƒæ˜¯ä½œä¸ºå‡½æ•°æŒ‡é’ˆæä¾›çš„ï¼Œé€šå¸¸æ¯”ä½¿ç”¨`std::sort()`æ—¶è°ƒç”¨çš„æ™®é€šæ¯”è¾ƒå‡½æ•°æ…¢å¾—å¤šï¼Œåè€…å¯èƒ½ä¼šè¢«ç¼–è¯‘å™¨å†…è”

### æœ€ä½³å®è·µ

1. ä½¿ç”¨å—é™ç®—æ³•ï¼šåœ¨ C++20 ä¸­å¼•å…¥çš„std::rangesä¸‹çš„å—é™ç®—æ³•æ¯”stdä¸‹çš„åŸºäºè¿­ä»£å™¨çš„ç®—æ³•æä¾›äº†ä¸€äº›ä¼˜åŠ¿ã€‚å—é™ç®—æ³•æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

   * æ”¯æŒæŠ•å½±ï¼Œç®€åŒ–å…ƒç´ çš„è‡ªå®šä¹‰æ¯”è¾ƒã€‚
   * æ”¯æŒèŒƒå›´è€Œä¸æ˜¯è¿­ä»£å™¨å¯¹ã€‚æ— éœ€å°†begin()å’Œend()è¿­ä»£å™¨ä½œä¸ºå•ç‹¬çš„å‚æ•°ä¼ é€’ã€‚
   * æ˜“äºæ­£ç¡®ä½¿ç”¨ï¼Œå¹¶ä¸”ç”±äºå— C++æ¦‚å¿µçš„é™åˆ¶ï¼Œåœ¨ç¼–è¯‘æœŸé—´æä¾›æè¿°æ€§é”™è¯¯æ¶ˆæ¯ã€‚

2. ä»…å¯¹éœ€è¦æ£€ç´¢çš„æ•°æ®è¿›è¡Œæ’åºï¼Œåˆç†é€‰æ‹©`sort()` ã€ `partial_sort()` å’Œ `nth_element()`
   
3. ä½¿ç”¨æ ‡å‡†ç®—æ³•è€Œä¸æ˜¯åŸå§‹çš„forå¾ªç¯

   * æ ‡å‡†ç®—æ³•æä¾›äº†æ€§èƒ½ã€‚å³ä½¿æ ‡å‡†åº“ä¸­çš„ä¸€äº›ç®—æ³•çœ‹èµ·æ¥å¾ˆçç¢ï¼Œå®ƒä»¬é€šå¸¸ä»¥ä¸æ˜æ˜¾çš„æ–¹å¼è¿›è¡Œäº†æœ€ä¼˜è®¾è®¡ã€‚
   * æ ‡å‡†ç®—æ³•æä¾›äº†å®‰å…¨æ€§ã€‚å³ä½¿æ˜¯æ›´ç®€å•çš„ç®—æ³•ä¹Ÿå¯èƒ½æœ‰ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œå¾ˆå®¹æ˜“å¿½è§†ã€‚
   * æ ‡å‡†ç®—æ³•æ˜¯æœªæ¥çš„ä¿éšœï¼›å¦‚æœæ‚¨æƒ³åˆ©ç”¨ SIMD æ‰©å±•ã€å¹¶è¡Œæ€§ç”šè‡³æ˜¯ä»¥åçš„ GPUï¼Œå¯ä»¥ç”¨æ›´åˆé€‚çš„ç®—æ³•æ›¿æ¢ç»™å®šçš„ç®—æ³•ï¼ˆå‚è§ç¬¬åå››ç« ï¼Œå¹¶è¡Œç®—æ³•ï¼‰ã€‚
   * æ ‡å‡†ç®—æ³•æœ‰è¯¦ç»†çš„æ–‡æ¡£ã€‚

## 6. èŒƒå›´å’Œè§†å›¾

éšç€ C++20 å¼•å…¥ Ranges åº“ï¼Œæˆ‘ä»¬åœ¨å®ç°ç®—æ³•æ—¶ä»æ ‡å‡†åº“ä¸­å—ç›Šçš„æ–¹å¼å¾—åˆ°äº†é‡å¤§æ”¹è¿›ï¼š

* æ¦‚å¿µï¼ˆConceptsï¼‰ï¼šå®šä¹‰äº†å¯¹è¿­ä»£å™¨å’ŒèŒƒå›´çš„è¦æ±‚ï¼Œç°åœ¨å¯ä»¥ç”±ç¼–è¯‘å™¨æ›´å¥½åœ°æ£€æŸ¥ï¼Œå¹¶åœ¨å¼€å‘è¿‡ç¨‹ä¸­æä¾›æ›´å¤šçš„å¸®åŠ©ã€‚
* <algorithm> å¤´æ–‡ä»¶ä¸­æ‰€æœ‰å‡½æ•°çš„æ–°é‡è½½ç‰ˆæœ¬éƒ½ä½¿ç”¨äº†ä¸Šè¿°æ¦‚å¿µè¿›è¡Œçº¦æŸï¼Œå¹¶æ¥å—èŒƒå›´ä½œä¸ºå‚æ•°ï¼Œè€Œä¸æ˜¯è¿­ä»£å™¨å¯¹ã€‚
* è¿­ä»£å™¨å¤´æ–‡ä»¶ä¸­å—çº¦æŸçš„è¿­ä»£å™¨ã€‚
* èŒƒå›´è§†å›¾ï¼ˆRange viewsï¼‰ï¼Œä½¿å¾—ç®—æ³•å¯ä»¥ç»„åˆã€‚

ç®—æ³•åº“çš„å±€é™ä¹‹ä¸€ä½“ç°åœ¨å¯ç»„åˆæ€§ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸ªStudentç±»ï¼Œéœ€è¦å¾—åˆ°ç‰¹å®šå¹´çº§çš„è€ƒè¯•æœ€é«˜åˆ†ï¼š

```cpp
struct Student {
Â Â int year_{};
Â Â int score_{};
Â Â std::string name_{};
Â Â // ...
}; 

// ä¸€èˆ¬æ€è·¯
auto get_max_score(const std::vector<Student>& students, int year) {
  auto by_year = = { return s.year_ == year; }; 
  // The student list needs to be copied in
  // order to filter on the year
  auto v = std::vector<Student>{};
  // ä½¿ç”¨copy_if()å’Œstd::back_inserter()æ—¶ä¼šåˆ›å»ºä¸å¿…è¦çš„Studentå¯¹è±¡çš„å‰¯æœ¬
  std::ranges::copy_if(students, std::back_inserter(v), by_year); 
  auto it = std::ranges::max_element(v, std::less{}, &Student::score_);
  return it != v.end() ? it->score_ : 0; 
} 

// C20å†™æ³•
auto max_value(auto&& range) {
  const auto it = std::ranges::max_element(range);
  return it != range.end() ? *it : 0;
}
auto get_max_score(const std::vector<Student>& students, int year) {
  const auto by_year = = { return s.year_ == year; };
  return max_value(students 
    | std::views::filter(by_year)
    | std::views::transform(&Student::score_));
} 
```

### ä»Rangesåº“ç†è§£è§†å›¾

**Views in the Ranges library are lazy evaluated iterations over a range. Technically, they are only iterators with built-in logic, but syntactically, they provide a very pleasant syntax for many common operations.**

```cpp
auto numbers = std::vector{1, 2, 3, 4};
auto square = [](auto v) {  return v * v; };  // ä¸æ˜¯numberså€¼å¹³æ–¹çš„å‰¯æœ¬
auto squared_view = std::views::transform(numbers, square);
for (auto s : squared_view) { // The square lambda is invoked here
  std::cout << s << " ";  // æ¯æ¬¡è®¿é—®æ—¶è°ƒç”¨ std::transform()ï¼Œå³ lazy evaluated
}
```

å¦‚æœè¦æŒä¹…åŒ–ï¼Œå¯ä»¥ä½¿ç”¨`std::ranges::copy()`å°†è§†å›¾ç‰©åŒ–ä¸ºå®¹å™¨ã€‚

```cpp
// è¿‡æ»¤è§†å›¾ï¼Œæ»¡è¶³æ¡ä»¶çš„å…ƒç´ ï¼Œåœ¨éå†è§†å›¾æ—¶å¯è§
auto v = std::vector{4, 5, 6, 7, 6, 5, 4};
auto odd_view = 
  std::views::filter(v, [](auto i){ return (i % 2) == 1; });
for (auto odd_number : odd_view) {
  std::cout << odd_number << " ";
}
// Output: 5 7 5
```

```cpp
// è§†å›¾å¯ä»¥å»ºç«‹åœ¨å¤šä¸ªå¯è¿­ä»£å®¹å™¨ä¸Šï¼Œçœ‹èµ·æ¥åƒæ˜¯å•ä¸€åˆ—è¡¨
auto list_of_lists = std::vector<std::vector<int>> {
  {1, 2},
  {3, 4, 5},
  {5},
  {4, 3, 2, 1}
};
auto flattened_view = std::views::join(list_of_lists);
for (auto v : flattened_view) 
  std::cout << v << " ";
// Output: 1 2 3 4 5 5 4 3 2 1

auto max_value = *std::ranges::max_element(flattened_view);
// max_value is 5 
```

#### è§†å›¾æ˜¯å¯ç»„åˆçš„

The full power of views comes from the ability to combine them. 

è§†å›¾å¹¶ä¸æ‹·è´æ•°æ®ï¼Œå› æ­¤å¯ä»¥åœ¨ä¸€ä¸ªæ•°æ®é›†åˆä¸Šè¡¨è¾¾å¤šä¸ªæ“ä½œï¼Œå®é™…ä»…åœ¨å†…éƒ¨è¿­ä»£ä¸€æ¬¡

```cpp
auto get_max_score(const std::vector<Student>& s, int year) {
  auto by_year = = { return s.year_ == year; };

  auto v1 = std::ranges::ref_view{s}; // Wrap container in a view
  auto v2 = std::ranges::filter_view{v1, by_year};
  auto v3 = std::ranges::transform_view{v2, &Student::score_};
  auto it = std::ranges::max_element(v3);
Â Â return it != v3.end() ? *it : 0;
}

// ç®€å†™
using namespace std::ranges;
auto scores = transform_view{filter_view{ref_view{s}, by_year}, &Student::score_};

// ä½¿ç”¨èŒƒå›´é€‚é…å™¨
using namespace std::views;
auto scores = transform(filter(s, by_year), &Student::score_); 
```

æ€»ä¹‹ï¼ŒRanges åº“ä¸­çš„æ¯ä¸ªè§†å›¾åŒ…æ‹¬ï¼š

* ä¸€ä¸ªç±»æ¨¡æ¿ï¼ˆå®é™…è§†å›¾ç±»å‹ï¼‰ï¼Œå®ƒæ“ä½œè§†å›¾å¯¹è±¡ï¼Œä¾‹å¦‚`std::ranges::transform_view`ã€‚è¿™äº›è§†å›¾ç±»å‹å¯ä»¥åœ¨å‘½åç©ºé—´`std::ranges`ä¸‹æ‰¾åˆ°ã€‚

* ä¸€ä¸ªèŒƒå›´é€‚é…å™¨å¯¹è±¡ï¼Œå®ƒä»èŒƒå›´åˆ›å»ºè§†å›¾ç±»çš„å®ä¾‹ï¼Œä¾‹å¦‚`std::views::transform`ã€‚æ‰€æœ‰èŒƒå›´é€‚é…å™¨éƒ½å®ç°äº†`operator()()`å’Œ`operator|()`ï¼Œè¿™ä½¿å¾—å¯ä»¥ä½¿ç”¨ç®¡é“è¿ç®—ç¬¦æˆ–åµŒå¥—æ¥ç»„åˆè½¬æ¢ã€‚èŒƒå›´é€‚é…å™¨å¯¹è±¡ä½äºå‘½åç©ºé—´`std::views`ä¸‹ã€‚

#### è§†å›¾æ˜¯å…·æœ‰å¤æ‚æ€§ä¿è¯çš„éæ‹¥æœ‰èŒƒå›´

Ranges åº“ä¸­çš„è§†å›¾ç±»å‹ä¿è¯åœ¨å¸¸æ•°æ—¶é—´å¤æ‚åº¦å†…å®Œæˆæ„é€ ã€å¤åˆ¶å’Œææ„ã€‚

#### è§†å›¾ä¸ä¼šæ”¹å˜åº•å±‚å®¹å™¨

#### è§†å›¾å¯ä»¥å®ä½“åŒ–ä¸ºå®¹å™¨

#### è§†å›¾æ˜¯å»¶è¿Ÿè®¡ç®—çš„ï¼ˆæƒ°æ€§è¯„ä¼°ï¼‰

### æ ‡å‡†åº“çš„è§†å›¾

åœ¨C++20ä¹‹å‰ï¼Œæ ‡å‡†åº“ä¹Ÿæä¾›äº†ç±»ä¼¼çš„éæ‹¥æœ‰ï¼ˆNon-owningï¼‰è§†å›¾, std::string_view std::span

#### Range views

```cpp
// 1. ç”Ÿæˆ
for (auto i : std::views::iota(-2, 2)) {
  std::cout << i << ' ';
}
// Prints -2 -1 0 1 

// 2. è½¬æ¢
std::views::transform   // è½¬æ¢å…ƒç´ 
std::views::reverse     // åè½¬å…ƒç´ 
std::views::split       // åˆ†å‰²å…ƒç´ 
std::views::join        // åˆå¹¶å…ƒç´ 

auto csv = std::string{"10,11,12"};
auto digits = csv 
  | std::views::split(',')      // [ [1, 0], [1, 1], [1, 2] ]
  | std::views::join;           // [ 1, 0, 1, 1, 1, 2 ]
for (auto i : digits) {   std::cout << i; }
// Prints 101112 

// 3. é‡‡æ ·
std::views::filter     // è¿‡æ»¤å…ƒç´ 
std::views::take       // å–å‰nä¸ªå…ƒç´ 
std::views::drop       // è·³è¿‡å‰nä¸ªå…ƒç´ 

auto vec = std::vector{1, 2, 3, 4, 5, 4, 3, 2, 1};
Â auto v = vec
Â Â  | std::views::drop_while([](auto i) { return i < 5; })
Â Â Â | std::views::take(3);
Â for (auto i : v) { std::cout << i << " "; }
// Prints 5 4 3 

// 4. å®ç”¨
// å½“æ‚¨æœ‰æƒ³è¦è½¬æ¢æˆ–è§†ä¸ºè§†å›¾çš„ä¸œè¥¿æ—¶ï¼Œå®ƒä»¬éå¸¸æ–¹ä¾¿ã€‚åœ¨è¿™äº›è§†å›¾ç±»åˆ«ä¸­çš„ä¸€äº›ç¤ºä¾‹æ˜¯ref_viewã€all_viewã€subrangeã€countedå’Œistream_viewã€‚
```

#### é‡æ–°å®¡è§† std::string_view å’Œ std::span

## 7.å†…å­˜ç®¡ç†

å¤§å¤šæ•°æ“ä½œç³»ç»Ÿéƒ½æ˜¯è™šæ‹Ÿå†…å­˜æ“ä½œç³»ç»Ÿï¼Œå®ƒä»¬æä¾›äº†ä¸€ä¸ªå‡è±¡ï¼Œå³ä¸€ä¸ªè¿›ç¨‹æ‹¥æœ‰äº†æ‰€æœ‰çš„å†…å­˜ã€‚æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„**è™šæ‹Ÿåœ°å€ç©ºé—´**ã€‚è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­çš„åœ°å€ç”±æ“ä½œç³»ç»Ÿå’Œå¤„ç†å™¨çš„å†…å­˜ç®¡ç†å•å…ƒï¼ˆMMUï¼‰æ˜ å°„åˆ°ç‰©ç†åœ°å€ã€‚æ¯æ¬¡è®¿é—®å†…å­˜åœ°å€æ—¶éƒ½ä¼šå‘ç”Ÿè¿™ç§æ˜ å°„æˆ–è½¬æ¢ã€‚

åˆ†é¡µ&ç¼ºé¡µä¸­æ–­

**è¿›ç¨‹å†…å­˜**ï¼š

**æ ˆ**åœ¨è®¸å¤šæ–¹é¢ä¸å †ä¸åŒã€‚ä»¥ä¸‹æ˜¯æ ˆçš„ä¸€äº›ç‹¬ç‰¹å±æ€§ï¼š

* æ ˆæ˜¯ä¸€ä¸ªè¿ç»­çš„å†…å­˜å—ã€‚
* å®ƒæœ‰ä¸€ä¸ªå›ºå®šçš„æœ€å¤§å¤§å°ã€‚å¦‚æœç¨‹åºè¶…å‡ºæœ€å¤§æ ˆå¤§å°ï¼Œç¨‹åºå°†å´©æºƒã€‚è¿™ç§æƒ…å†µç§°ä¸ºæ ˆæº¢å‡ºã€‚
* æ ˆå†…å­˜æ°¸è¿œä¸ä¼šå˜å¾—åˆ†æ•£ã€‚
* ä»æ ˆä¸­åˆ†é…å†…å­˜ï¼ˆå‡ ä¹ï¼‰æ€»æ˜¯å¾ˆå¿«çš„ã€‚é¡µé¢é”™è¯¯å¯èƒ½ä¼šå‘ç”Ÿï¼Œä½†å¾ˆå°‘è§ã€‚
* ç¨‹åºä¸­çš„æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„æ ˆã€‚

**å †**ï¼ˆ*è‡ªç”±å­˜å‚¨åŒº*ï¼‰

```cpp
{
  // C++17ä¹‹å‰ placement_new
  auto* memory = std::malloc(sizeof(User));
  // ::å‰é¢çš„åŒå†’å·ç¡®ä¿äº†ä»å…¨å±€å‘½åç©ºé—´è¿›è¡Œè§£æï¼Œä»¥é¿å…é€‰æ‹©operator newçš„é‡è½½ç‰ˆæœ¬ã€‚
  auto* user = ::new (memory) User("john"); 

  user->~User();
  std::free(memory);
}

{
  // C++17, memoryä¸­å¼•å…¥äº†ä¸€äº›å‡½æ•°æ¥å®ç°
  // ä½¿ç”¨ä¸€äº›ä»¥std::uninitialized_å¼€å¤´çš„å‡½æ•°æ¥æ„é€ ã€å¤åˆ¶å’Œç§»åŠ¨å¯¹è±¡åˆ°æœªåˆå§‹åŒ–çš„å†…å­˜åŒºåŸŸ
  // ä½¿ç”¨std::destroy_at()åœ¨ç‰¹å®šå†…å­˜åœ°å€ä¸Šé”€æ¯å¯¹è±¡ï¼Œè€Œæ— éœ€é‡Šæ”¾å†…å­˜
  auto* memory = std::malloc(sizeof(User));
  auto* user_ptr = reinterpret_cast<User*>(memory);
  std::uninitialized_fill_n(user_ptr, 1, User{"john"});
  std::destroy_at(user_ptr);
  std::free(memory); 
}

{
  // C++ 20 
  std::construct_at(user_ptr, User{"john"});        // C++20 
}
```

### å†…å­˜å¯¹é½

CPU æ¯æ¬¡ä»å†…å­˜ä¸­è¯»å–ä¸€ä¸ªå­—æ—¶ï¼Œå°†å…¶è¯»å…¥å¯„å­˜å™¨ã€‚64 ä½æ¶æ„ä¸Šçš„å­—å¤§å°ä¸º 64 ä½ï¼Œ32 ä½æ¶æ„ä¸Šä¸º 32 ä½ã€‚**å¯¹é½æ˜¯ä¸€ä¸ªå®ç°å®šä¹‰çš„æ•´æ•°å€¼ï¼Œè¡¨ç¤ºç»™å®šå¯¹è±¡å¯ä»¥åˆ†é…çš„è¿ç»­åœ°å€ä¹‹é—´çš„å­—èŠ‚æ•°ã€‚**

ä½¿ç”¨ `alignof` æ“ä½œç¬¦ï¼Œå¦‚ `std::cout << alignof(int) << '\n';` å¯æŸ¥çœ‹ `int` ç±»å‹å¯¹é½è¦æ±‚ï¼Œå¯èƒ½è¾“å‡º 4ï¼Œå³ 4 å­—èŠ‚å¯¹é½ã€‚

**å¯ç§»æ¤æ€§é—®é¢˜**ï¼šC++ æ ‡å‡†æœªè§„å®šæœ‰æ•ˆåœ°å€èµ·å§‹å€¼ï¼Œå®é™…å¹³å°å¤šä» 0 å¼€å§‹ï¼Œè™½å¯ç”¨å–æ¨¡è¿ç®—ç¬¦æ£€æŸ¥ï¼Œä½†ç¼–å†™å®Œå…¨å¯ç§»æ¤ä»£ç éœ€ç”¨ `std::align()`

```cpp
bool is_aligned(void* ptr, std::size_t alignment) {
  assert(ptr != nullptr);
  // ç¡®ä¿ `ptr` ä¸ä¸ºç©ºï¼Œ`alignment` æ˜¯ 2 çš„å¹‚ï¼ˆç”¨ `std::has_single_bit()` æ£€æŸ¥ï¼‰
  assert(std::has_single_bit(alignment)); // Power of 2
  auto s = std::numeric_limits<std::size_t>::max();
  auto aligned_ptr = ptr;
  // è°ƒç”¨ `std::align()` è°ƒæ•´æŒ‡é’ˆï¼Œæ¯”è¾ƒåŸå§‹æŒ‡é’ˆå’Œè°ƒæ•´åæŒ‡é’ˆåˆ¤æ–­æ˜¯å¦å·²å¯¹é½
  std::align(alignment, 1, aligned_ptr, s);
  return ptr == aligned_ptr;
} 
```

`new` å’Œ `malloc()` ä¿è¯è¿”å›é€‚åˆä»»ä½•æ ‡é‡ç±»å‹çš„å†…å­˜ï¼Œ`<cstddef>` ä¸­çš„ `std::max_align_t` ç±»å‹ï¼Œå¯¹é½è¦æ±‚è‡³å°‘ä¸æ‰€æœ‰æ ‡é‡ç±»å‹ä¸€æ ·ä¸¥æ ¼ï¼Œå³ä½¿è¯·æ±‚ `char` å†…å­˜ï¼Œä¹Ÿé€‚åˆ `std::max_align_t`ã€‚

**è¿ç»­åˆ†é… `char` æƒ…å†µ**ï¼šè¿ç»­ç”¨ `new` åˆ†é… `char`ï¼Œ`p1` å’Œ `p2` é—´ç©ºé—´å–å†³äº `std::max_align_t` å¯¹é½è¦æ±‚ï¼Œå¦‚ç³»ç»Ÿä¸­ä¸º 16 å­—èŠ‚ï¼Œæ¯ä¸ª `char` å®ä¾‹é—´æœ‰ 15 å­—èŠ‚ã€‚

**å£°æ˜å˜é‡æ—¶æŒ‡å®š**ï¼šä½¿ç”¨ `alignas` æŒ‡å®šç¬¦ï¼Œå¦‚ `alignas(64) int x{}; alignas(64) int y{};` å¯ç¡®ä¿ `x` å’Œ `y` ä½äºä¸åŒç¼“å­˜è¡Œã€‚

**å®šä¹‰ç±»å‹æ—¶æŒ‡å®š**ï¼šå¦‚ `struct alignas(64) CacheLine { std::byte data[64]; };` åˆ›å»ºçš„ç»“æ„ä½“å¯¹è±¡ä¼šæŒ‰ 64 å­—èŠ‚è‡ªå®šä¹‰å¯¹é½ã€‚

**å †ä¸Šåˆ†é…ä¸éé»˜è®¤å¯¹é½** C++17 å¼•å…¥ `operator new()` å’Œ `operator delete()` æ–°é‡è½½ï¼Œæ¥å— `std::align_val_t` ç±»å‹å¯¹é½å‚æ•°ã€‚`<cstdlib>` ä¸­ `aligned_alloc()` å‡½æ•°å¯æ‰‹åŠ¨åˆ†é…å¯¹é½çš„å †å†…å­˜ã€‚

```cpp
constexpr auto ps = std::size_t{4096};      // Page size
struct alignas(ps) Page {
    std::byte data_[ps];
};
auto* page = new Page{};                    // Memory page
assert(is_aligned(page, ps));               // True
// Use page ...
delete page; 
```

**æ³¨æ„äº‹é¡¹**

- å†…å­˜é¡µé¢ä¸æ˜¯ C++ æŠ½è±¡æœºå™¨ä¸€éƒ¨åˆ†ï¼Œæ— å¯ç§»æ¤æ–¹æ³•ç¼–ç¨‹è·å–å½“å‰ç³»ç»Ÿé¡µé¢å¤§å°ï¼ŒUnix ç³»ç»Ÿå¯ç”¨ `boost::mapped_region::get_page_size()` æˆ– `getpagesize()`ã€‚
- æ”¯æŒçš„å¯¹é½é›†ç”±ä½¿ç”¨çš„æ ‡å‡†åº“å®ç°å®šä¹‰ï¼Œè€Œé C++ æ ‡å‡†ã€‚

**å¡«å……**ï¼Œæ³¨æ„è®¾ç½®æ•°æ®æˆå‘˜çš„é¡ºåºï¼Œå¯ä»¥èµ·åˆ°èŠ‚çº¦å†…å­˜çš„æ•ˆæœï¼š

```cpp
class Document {
  bool is_cached_{};
  std::byte padding1[7]; // Invisible padding inserted by compiler
  double rank_{};
  int id_{};
  std::byte padding2[4]; // Invisible padding inserted by compiler
}; 

std::cout << sizeof(Document) << '\n'; // Possible output is 24 

// Version 2 of Document class after padding
class Document { 
  double rank_{}; 
  int id_{}; 
  bool is_cached_{}; 
  std::byte padding[3]; // Invisible padding inserted by compiler 
};

std::cout << sizeof(Document) << '\n'; // Possible output is 16 
```

### å†…å­˜æ‰€æœ‰æƒ

* å±€éƒ¨å˜é‡ç”±å½“å‰ä½œç”¨åŸŸæ‹¥æœ‰ã€‚å½“ä½œç”¨åŸŸç»“æŸæ—¶ï¼Œåœ¨ä½œç”¨åŸŸå†…åˆ›å»ºçš„å¯¹è±¡å°†è¢«è‡ªåŠ¨é”€æ¯
* é™æ€å’Œå…¨å±€å˜é‡ç”±ç¨‹åºæ‹¥æœ‰ï¼Œå¹¶å°†åœ¨ç¨‹åºç»ˆæ­¢æ—¶è¢«é”€æ¯
* æ•°æ®æˆå‘˜ç”±å®ƒä»¬æ‰€å±çš„ç±»çš„å®ä¾‹æ‹¥æœ‰
* åªæœ‰åŠ¨æ€å˜é‡æ²¡æœ‰é»˜è®¤æ‰€æœ‰è€…ï¼Œç¨‹åºå‘˜éœ€è¦ç¡®ä¿æ‰€æœ‰åŠ¨æ€åˆ†é…çš„å˜é‡éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…æ¥æ§åˆ¶å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ

æ˜ç¡®è¡¨è¾¾æ‰€æœ‰æƒï¼Œæœ€å°åŒ–æ‰‹åŠ¨å†…å­˜ç®¡ç†

#### éšå¼å¤„ç†èµ„æº

é€šè¿‡RAIIæŠ€æœ¯éšå¼å¤„ç†èµ„æº

å¯ä»¥ä½¿ç”¨æ ‡å‡†å®¹å™¨æ¥å¤„ç†å¯¹è±¡çš„é›†åˆï¼ˆé€šè¿‡å®¹å™¨ç®¡ç†åŠ¨æ€å†…å­˜ï¼Œè€Œä¸æ˜¯æ‰‹åŠ¨ `new` å’Œ `delete`ï¼‰

ä½¿ç”¨ `std::optional` æ¥å¤„ç†å¯èƒ½å­˜åœ¨æˆ–å¯èƒ½ä¸å­˜åœ¨çš„å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ

å°½é‡ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆä»£æ›¿è£¸æŒ‡é’ˆï¼š

* ç‹¬å æŒ‡é’ˆä¹Ÿéå¸¸é«˜æ•ˆï¼Œå› ä¸ºä¸æ™®é€šåŸå§‹æŒ‡é’ˆç›¸æ¯”ï¼Œå®ƒä»¬å‡ ä¹æ²¡æœ‰æ€§èƒ½å¼€é”€ã€‚è½»å¾®çš„å¼€é”€æ˜¯ç”±äº`std::unique_ptr`å…·æœ‰éå¹³å‡¡çš„ææ„å‡½æ•°ï¼Œè¿™æ„å‘³ç€ï¼ˆä¸åŸå§‹æŒ‡é’ˆä¸åŒï¼‰åœ¨ä¼ é€’ç»™å‡½æ•°æ—¶æ— æ³•å°†å…¶ä¼ é€’åˆ° CPU å¯„å­˜å™¨ä¸­ã€‚è¿™ä½¿å®ƒä»¬æ¯”åŸå§‹æŒ‡é’ˆæ…¢ã€‚

### å°å¯¹è±¡ä¼˜åŒ–

```cpp
// å­—ç¬¦ä¸²çš„å°å¯¹è±¡ä¼˜åŒ–çš„ç®€å•ç¤ºæ„
struct Long { 
  size_t capacity_{}; 
  size_t size_{}; 
  char* data_{}; 
}; 

struct Short { 
  unsigned char size_{};
  char data_[23]{}; 
};

union u_ { 
  Short short_layout_; 
  Long long_layout_; 
};
```

libc++åœ¨é•¿æ¨¡å¼ä¸‹ä½¿ç”¨capacity_æ•°æ®æˆå‘˜çš„æœ€ä½æœ‰æ•ˆä½ï¼Œè€Œåœ¨çŸ­æ¨¡å¼ä¸‹ä½¿ç”¨size_æ•°æ®æˆå‘˜çš„æœ€ä½æœ‰æ•ˆä½ã€‚å¯¹äºé•¿æ¨¡å¼ï¼Œè¿™ä¸ªä½æ˜¯å¤šä½™çš„ï¼Œå› ä¸ºå­—ç¬¦ä¸²æ€»æ˜¯åˆ†é… 2 çš„å€æ•°çš„å†…å­˜å¤§å°ã€‚åœ¨çŸ­æ¨¡å¼ä¸‹ï¼Œå¯ä»¥åªä½¿ç”¨ 7 ä½æ¥å­˜å‚¨å¤§å°ï¼Œä»¥ä¾¿ä¸€ä¸ªä½å¯ä»¥ç”¨äºæ ‡å¿—ã€‚

### è‡ªå®šä¹‰å†…å­˜ç®¡ç†

> å¯ä»¥ç»“åˆ å†…å­˜åˆ†é…ç®—æ³• + PMR å®ç°ä¸€ä¸ªä¾‹å­

## 8. ç¼–è¯‘æ—¶ç¼–ç¨‹

### æ¨¡ç‰ˆå…ƒç¼–ç¨‹

ç•¥è¿‡éƒ¨åˆ†åŸºç¡€å†…å®¹

C++20 å¼•å…¥äº†ä¸€ç§æ–°çš„ç¼©å†™è¯­æ³•ï¼Œç”¨äºç¼–å†™å‡½æ•°æ¨¡æ¿ï¼Œé‡‡ç”¨äº†é€šç”¨ lambda ä½¿ç”¨çš„ç›¸åŒé£æ ¼ã€‚é€šè¿‡ä½¿ç”¨autoä½œä¸ºå‡½æ•°å‚æ•°ç±»å‹ï¼Œæˆ‘ä»¬å®é™…ä¸Šåˆ›å»ºçš„æ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå¸¸è§„å‡½æ•°

```cpp
// pow_n accepts any number type 
template <typename T> 
auto pow_n(const T& v, int n) { 
  auto product = T{1}; 
  for (int i = 0; i < n; ++i) { 
    product *= v; 
  }
  return product; 
} 

// C20
auto pow_n(const auto &v, int n) {  // Declares a function template
  typename std::remove_cvref<decltype(v)>::type product{1}; 
  for (int i = 0; i < n; ++i) { product *= v; } 
  return product;
}
```

åœ¨ C++20 ä¹‹å‰ï¼Œåœ¨é€šç”¨ lambda çš„ä¸»ä½“ä¸­ç»å¸¸çœ‹åˆ°decltypeã€‚ç„¶è€Œï¼Œç°åœ¨å¯ä»¥é€šè¿‡å‘é€šç”¨ lambda æ·»åŠ æ˜¾å¼æ¨¡æ¿å‚æ•°æ¥é¿å…ç›¸å½“ä¸æ–¹ä¾¿çš„decltype:

```cpp
auto pow_n = []<class T>(const T& v, int n) { 
  auto product = T{1};
  for (int i = 0; i < n; ++i) { product *= v; }
  return product;
}; 
```

### ç±»å‹ç‰¹å¾ï¼ˆ`<type_traits>`ï¼‰

ä¸ºäº†æå–æœ‰å…³æ¨¡æ¿ç±»å‹çš„ä¿¡æ¯ï¼Œæ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªç±»å‹ç‰¹å¾åº“ï¼Œè¯¥åº“åœ¨`<type_traits>`å¤´æ–‡ä»¶ä¸­å¯ç”¨ã€‚æ‰€æœ‰ç±»å‹ç‰¹å¾éƒ½åœ¨ç¼–è¯‘æ—¶è¯„ä¼°ã€‚

æœ‰ä¸¤ç±»ç±»å‹ç‰¹å¾ï¼š

* è¿”å›å…³äºç±»å‹ä¿¡æ¯çš„ç±»å‹ç‰¹å¾ï¼Œä½œä¸ºå¸ƒå°”å€¼æˆ–æ•´æ•°å€¼ã€‚
* è¿”å›æ–°ç±»å‹çš„ç±»å‹ç‰¹å¾ã€‚è¿™äº›ç±»å‹ç‰¹å¾ä¹Ÿè¢«ç§°ä¸ºå…ƒå‡½æ•°ã€‚

### å¸¸é‡è¡¨è¾¾å¼

`constexpr`å…³é”®å­—ä¹Ÿå¯ä»¥ä¸å‡½æ•°ä¸€èµ·ä½¿ç”¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå‘Šè¯‰ç¼–è¯‘å™¨æŸä¸ªå‡½æ•°æ‰“ç®—åœ¨ç¼–è¯‘æ—¶è¯„ä¼°ã€‚

`constexpr`å‡½æ•°æœ‰ä¸€äº›é™åˆ¶ï¼›ä¸å…è®¸æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

* å¤„ç†æœ¬åœ°é™æ€å˜é‡
* å¤„ç†thread_localå˜é‡
* è°ƒç”¨ä»»ä½•å‡½æ•°ï¼Œæœ¬èº«ä¸æ˜¯constexprå‡½æ•°

```cpp
constexpr auto sum(int x, int y, int z) { return x + y + z; } 

constexpr auto value = sum(3, 4, 5); 
// ç”±äºsum()çš„ç»“æœç”¨äºå¸¸é‡è¡¨è¾¾å¼ï¼Œå¹¶ä¸”å…¶æ‰€æœ‰å‚æ•°éƒ½å¯ä»¥åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œå› æ­¤ç¼–è¯‘å™¨å°†ç”Ÿæˆ
const auto value = 12; 
// è°ƒç”¨sum()å¹¶å°†ç»“æœå­˜å‚¨åœ¨æœªæ ‡è®°ä¸ºconstexprçš„å˜é‡ä¸­ï¼Œç¼–è¯‘å™¨å¯èƒ½ï¼ˆå¾ˆå¯èƒ½ï¼‰åœ¨ç¼–è¯‘æ—¶è¯„ä¼°sum()
auto value = sum(3, 4, 5); // value is not constexpr 
```

`constexpr`å‡½æ•°å¯ä»¥åœ¨è¿è¡Œæ—¶æˆ–ç¼–è¯‘æ—¶è°ƒç”¨ã€‚å¦‚æœæˆ‘ä»¬æƒ³é™åˆ¶å‡½æ•°çš„ä½¿ç”¨ï¼Œä½¿å…¶åªåœ¨ç¼–è¯‘æ—¶è°ƒç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…³é”®å­—`consteval`è€Œä¸æ˜¯`constexpr`ã€‚å‡è®¾æˆ‘ä»¬æƒ³ç¦æ­¢åœ¨è¿è¡Œæ—¶ä½¿ç”¨`sum()`ã€‚ä½¿ç”¨ C++20ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹ä»£ç å®ç°ï¼š

```cpp
// ç«‹å³å‡½æ•°
consteval auto sum(int x, int y, int z) { return x + y + z; } 
```

`if constexpr`ç¼–è¯‘æœŸæ¡ä»¶åˆ¤æ–­è¯­å¥ï¼Œå®ƒå…è®¸åœ¨ç¼–è¯‘æœŸé—´æ ¹æ®æ¡ä»¶é€‰æ‹©æ˜¯å¦ç¼–è¯‘æŸæ®µä»£ç ã€‚

```cpp
if constexpr (constant_expression) {
    // å¦‚æœ constant_expression ä¸º trueï¼Œåˆ™ç¼–è¯‘è¿™æ®µä»£ç ï¼Œå¿½ç•¥elseåˆ†æ”¯
} else {
    // å¦‚æœ constant_expression ä¸º falseï¼Œåˆ™ç¼–è¯‘è¿™æ®µä»£ç ï¼Œå¿½ç•¥ifåˆ†æ”¯
}
```

ä¸‹é¢ä¾‹å­ä¼šç¼–è¯‘å¤±è´¥ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸ç†è§£ç¨‹åºåˆ†æ”¯æ˜¯å¦å¯è¾¾ï¼Œåœ¨ä»£ç ç”Ÿæˆæ—¶ä¼šç”Ÿæˆå¯¹åº”çš„elseåˆ†æ”¯ã€‚

```cpp
template <typename T> 
auto generic_mod(const T& v, const T& n) -> T {
  assert(n != 0);
  if (std::is_floating_point_v<T>) { return std::fmod(v, n); }
  else { return v % n; }
} 

// ç­‰ä»·äº
auto generic_mod(const float& v, const float& n) -> float {
  assert(n != 0);
  if (true) { return std::fmod(v, n); }
  else { return v % n; } // Will not compile
} 

```

æ”¹å†™ä¸º `if constexpr` å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼š

```cpp
template <typename T> 
auto generic_mod(const T& v, const T& n) -> T { 
  assert(n != 0);
  if constexpr (std::is_floating_point_v<T>) {
    return std::fmod(v, n);
  } else {                 // If T is a floating point,
    return v % n;          // this code is eradicated
  }
} 

// ç­‰ä»·äº
auto generic_mod(const float& v, const float& n) -> float { 
  assert(n != 0);
  return std::fmod(v, n); 
} 

```

ä½¿ç”¨`static_assert()`åœ¨ç¼–è¯‘ç¨‹åºæ—¶æ•è·ç¼–ç¨‹é”™è¯¯

### `concept`å’Œ`requires`

![error in template compile](https://raw.githubusercontent.com/TDAkory/ImageResources/master/img/CppLearn/error_in_template_compile.jpg
)

```cpp
// åŸºæœ¬ä¾‹å­
template <typename T>
concept FloatingPoint = std::is_floating_point_v<T>; 

// å¯ä»¥ä½¿ç”¨é€»è¾‘è¿ç®—ç¬¦ç»„åˆå¤šä¸ªçº¦æŸæ¡ä»¶
template <typename T>
concept Number = FloatingPoint<T> || std::is_integral_v<T>;

// å¯ä»¥ä½¿ç”¨ requires æ¥æ·»åŠ ä¸€ç»„è¯­å¥åˆ° concept ä¸­
template<typename T>
concept range = requires(T& t) {
  ranges::begin(t);
  ranges::end(t);
};
```

ä½¿ç”¨æ¦‚å¿µçº¦æŸç±»å‹

```cpp
// ä½¿ç”¨ concept çº¦æŸæ¨¡ç‰ˆå‡½æ•° æˆ– æ¨¡æ¿ç±»
template <typename T>
requires std::integral<T>
auto mod(T v, T n) { 
  return v % n;
}

template <typename T>
requires std::integral<T>
struct Foo {
  T value;
};

// æ›´ç´§å‡‘çš„å†™æ³•
template <std::integral T>
auto mod(T v, T n) { 
  return v % n;
}

template <std::integral T>
struct Foo {
  T value;
};

// å®šä¹‰å‡½æ•°æ¨¡æ¿æ—¶ä½¿ç”¨ç¼©å†™çš„å‡½æ•°æ¨¡æ¿å½¢å¼ï¼Œå¯ä»¥åœ¨autoå…³é”®å­—å‰é¢æ·»åŠ  concept
auto mod(std::integral auto v, std::integral auto n) {
  return v % n;
}

// è¿”å›ç±»å‹ä¹Ÿå¯ä»¥é€šè¿‡ä½¿ç”¨æ¦‚å¿µæ¥çº¦æŸ
std::integral auto mod(std::integral auto v, std::integral auto n) {
  return v % n;
} 
```

Point2Dæ¨¡æ¿çš„çº¦æŸç‰ˆæœ¬

```cpp
template<typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

template<typename T>
concept Point = requires<T p> {
  requires std::is_same_v<decltype(p.x()), decltype(p.y())>;
  requires Arithmetic<decltype(p.x())>;
};

std::floating_point auto dist(Point auto p1, Point auto p2) {
  â€¦â€¦
}

template <Arithmetic T> // T is now constrained!
class Point2D {
public:
  Point2D(T x, T y) : x_{x}, y_{y} {}
  auto x() { return x_; }
  auto y() { return y_; }
  // ...
private:
  T x_{};
  T y_{};
}; 
```

æ¥å£ç°åœ¨æ›´åŠ æè¿°æ€§ï¼Œå½“æˆ‘ä»¬å°è¯•ç”¨é”™è¯¯çš„å‚æ•°ç±»å‹å®ä¾‹åŒ–å®ƒæ—¶ï¼Œæˆ‘ä»¬å°†åœ¨å®ä¾‹åŒ–é˜¶æ®µè€Œä¸æ˜¯æœ€ç»ˆç¼–è¯‘é˜¶æ®µè·å¾—é”™è¯¯ã€‚

ç±»å‹å’Œæ¦‚å¿µéƒ½æŒ‡å®šäº†å¯¹è±¡ä¸Šæ”¯æŒçš„ä¸€ç»„æ“ä½œã€‚é€šè¿‡æ£€æŸ¥ç±»å‹æˆ–æ¦‚å¿µï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šæŸäº›å¯¹è±¡å¦‚ä½•æ„é€ ã€ç§»åŠ¨ã€æ¯”è¾ƒå’Œé€šè¿‡æˆå‘˜å‡½æ•°è®¿é—®ç­‰ã€‚

ä¸€ä¸ªé‡å¤§çš„åŒºåˆ«æ˜¯ï¼Œæ¦‚å¿µå¹¶ä¸è¯´ä»»ä½•å…³äºå¯¹è±¡å¦‚ä½•å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œè€Œç±»å‹é™¤äº†å…¶æ”¯æŒçš„æ“ä½œé›†ä¹‹å¤–è¿˜æä¾›äº†è¿™äº›ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç±»å‹ä¸Šä½¿ç”¨sizeofè¿ç®—ç¬¦ï¼Œä½†ä¸èƒ½åœ¨æ¦‚å¿µä¸Šä½¿ç”¨ã€‚

C++20 è¿˜åŒ…æ‹¬ä¸€ä¸ªæ–°çš„ `<concepts>` å¤´æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«é¢„å®šä¹‰çš„æ¦‚å¿µã€‚æ‚¨å·²ç»çœ‹åˆ°å…¶ä¸­ä¸€äº›æ¦‚å¿µçš„ä½œç”¨ã€‚è®¸å¤šæ¦‚å¿µéƒ½æ˜¯åŸºäºç±»å‹ç‰¹æ€§åº“ä¸­çš„ç‰¹æ€§ã€‚ç„¶è€Œï¼Œæœ‰ä¸€äº›åŸºæœ¬æ¦‚å¿µä»¥å‰æ²¡æœ‰ç”¨ç‰¹æ€§è¡¨è¾¾ã€‚å…¶ä¸­æœ€é‡è¦çš„æ˜¯æ¯”è¾ƒæ¦‚å¿µï¼Œå¦‚ `std::equality_comparable` å’Œ `std::totally_ordered`ï¼Œä»¥åŠå¯¹è±¡æ¦‚å¿µï¼Œå¦‚ `std::movable`ã€`std::copyable`ã€`std::regular` å’Œ `std::semiregular`ã€‚æˆ‘ä»¬ä¸ä¼šåœ¨æ ‡å‡†åº“çš„æ¦‚å¿µä¸ŠèŠ±è´¹æ›´å¤šæ—¶é—´ï¼Œä½†åœ¨å¼€å§‹å®šä¹‰è‡ªå·±çš„æ¦‚å¿µä¹‹å‰ï¼Œè¯·è®°ä½å°†å®ƒä»¬ç‰¢è®°åœ¨å¿ƒã€‚åœ¨æ­£ç¡®çš„æ³›åŒ–çº§åˆ«ä¸Šå®šä¹‰æ¦‚å¿µå¹¶ä¸æ˜¯ä»¶å®¹æ˜“çš„äº‹ï¼Œé€šå¸¸æ˜æ™ºçš„åšæ³•æ˜¯åŸºäºå·²ç»å­˜åœ¨çš„æ¦‚å¿µå®šä¹‰æ–°çš„æ¦‚å¿µã€‚


## 9.åŸºæœ¬å®ç”¨ç¨‹åº

ä»‹ç» C++å®ç”¨åº“ä¸­çš„ä¸€äº›åŸºæœ¬ç±»

* ä½¿ç”¨std::optionalè¡¨ç¤ºå¯é€‰å€¼

* ä½¿ç”¨std::pairã€std::tupleå’Œstd::tie()æ¥å›ºå®šå¤§å°çš„é›†åˆ

* ä½¿ç”¨æ ‡å‡†å®¹å™¨å­˜å‚¨å…·æœ‰std::anyå’Œstd::variantç±»å‹çš„å…ƒç´ çš„åŠ¨æ€å¤§å°é›†åˆ

### `std::optional<T>`

`std::optional`çš„è¯­æ³•ç±»ä¼¼äºæŒ‡é’ˆï¼›å€¼é€šè¿‡`operator*()`æˆ–`operator->()`è®¿é—®ã€‚å°è¯•ä½¿ç”¨`operator*()`æˆ–`operator->()`è®¿é—®ç©ºçš„å¯é€‰å€¼çš„å€¼æ˜¯æœªå®šä¹‰è¡Œä¸ºã€‚è¿˜å¯ä»¥ä½¿ç”¨`value()`æˆå‘˜å‡½æ•°è®¿é—®å€¼ï¼Œå¦‚æœå¯é€‰å€¼ä¸åŒ…å«å€¼ï¼Œåˆ™ä¼šæŠ›å‡º`std::bad_optional_access`å¼‚å¸¸ã€‚

å¦‚æœå¯¹std::optional<T>çš„å®¹å™¨è¿›è¡Œæ’åºï¼Œç©ºçš„å¯é€‰å€¼å°†å‡ºç°åœ¨å®¹å™¨çš„å¼€å¤´ï¼Œè€Œéç©ºçš„å¯é€‰å€¼å°†åƒé€šå¸¸ä¸€æ ·æ’åº

### å›ºå®šå¤§å°å¼‚æ„é›†åˆ

`std::pair` `std::tuple`

C++11 å¼•å…¥äº†ä¸€ä¸ªåä¸ºstd::tupleçš„æ–°å®ç”¨ç±»ï¼Œå®ƒæ˜¯std::pairçš„æ³›åŒ–ï¼Œå¯ä»¥å®¹çº³ä»»æ„æ•°é‡çš„å…ƒç´ ã€‚

```cpp
auto t = std::tuple<int, std::string, bool>{}; 
```

å¯ä»¥ä½¿ç”¨è‡ªç”±å‡½æ•°æ¨¡æ¿`std::get<Index>()`è®¿é—®std::tupleçš„å„ä¸ªå…ƒç´ ã€‚std::tupleç±»åŸºæœ¬ä¸Šæ˜¯ä¸€ä¸ªç®€å•çš„ç»“æ„ï¼Œå…¶æˆå‘˜å¯ä»¥é€šè¿‡ç¼–è¯‘æ—¶ç´¢å¼•è®¿é—®ã€‚

std::tupleåŒ…å«ä¸åŒç±»å‹çš„å…ƒç´ ï¼Œè€ŒåŸºäºèŒƒå›´çš„ for å¾ªç¯ä¸­const auto& vçš„ç±»å‹åªä¼šè¢«è¯„ä¼°ä¸€æ¬¡ï¼Œæ— æ³•é€‚é…å…ƒç»„ä¸­å¤šç§ä¸åŒç±»å‹çš„å…ƒç´ ï¼Œå› æ­¤è¿™ç±»ä»£ç æ— æ³•ç¼–è¯‘ã€‚

åŒæ—¶ï¼Œç”±äºè¿­ä»£å™¨ä¸èƒ½æ”¹å˜æŒ‡å‘çš„ç±»å‹ï¼Œstd::tupleä¸æä¾›begin()ã€end()æˆå‘˜å‡½æ•°åŠä¸‹æ ‡è¿ç®—ç¬¦[]ï¼Œå¸¸è§„è¿­ä»£ç®—æ³•ä¹Ÿä¸é€‚ç”¨ï¼Œæ‰€ä»¥éœ€è¦å…¶ä»–æ–¹æ³•æ¥å±•å¼€å…ƒç»„ã€‚

[godbolt](https://godbolt.org/z/nj9s7xjYf)

```cpp
// ä¸ºç‰¹å®šç´¢å¼•ç”Ÿæˆè°ƒç”¨çš„å‡½æ•°
template <size_t Index, typename Tuple, typename Func> 
void tuple_at(const Tuple& t, Func f) {
  const auto& v = std::get<Index>(t);
  std::invoke(f, v);
} 

// å¦‚æœç´¢å¼•ç­‰äºå…ƒç»„å¤§å°ï¼Œå®ƒä¼šç”Ÿæˆä¸€ä¸ªç©ºå‡½æ•°ã€‚å¦åˆ™ï¼Œå®ƒä¼šåœ¨ä¼ é€’çš„ç´¢å¼•å¤„æ‰§è¡Œ lambdaï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªç´¢å¼•å¢åŠ  1 çš„æ–°å‡½æ•°
template <typename Tuple, typename Func, size_t Index = 0> 
void tuple_for_each(const Tuple& t, const Func& f) {
  constexpr auto n = std::tuple_size_v<Tuple>;
  if constexpr(Index < n) {
    tuple_at<Index>(t, f);
    tuple_for_each<Tuple, Func, Index+1>(t, f);
  }
}

auto t = std::tuple{1, true, std::string{"Jedi"}};
tuple_for_each(t, [](const auto& v) { std::cout << v << " "; });
// Prints "1 true Jedi" 
```

åœ¨tuple_for_each()çš„åŸºç¡€ä¸Šï¼Œå¯ä»¥ä»¥ç±»ä¼¼çš„æ–¹å¼å®ç°è¿­ä»£å…ƒç»„çš„ä¸åŒç®—æ³•ã€‚ä»¥ä¸‹æ˜¯std::any_of()ä¸ºå…ƒç»„å®ç°çš„ç¤ºä¾‹

```cpp
template <typename Tuple, typename Func, size_t Index = 0> 
auto tuple_any_of(const Tuple& t, const Func& f) -> bool { 
  constexpr auto n = std::tuple_size_v<Tuple>; 
  if constexpr(Index < n) { 
    bool success = std::invoke(f, std::get<Index>(t)); 
    if (success) {
      return true;
    }
    return tuple_any_of<Tuple, Func, Index+1>(t, f); 
  } else { 
    return false; 
  } 
} 
```

C++17 å¼•å…¥ç»“æ„åŒ–ç»‘å®šæ¥ä¼˜é›…åœ°è®¿é—®å…ƒç»„ä¸­çš„å…ƒç´ 

```cpp
auto make_saturn() { return std::tuple{"Saturn"s, 82, true}; }
const auto& [name, n_moons, rings] = make_saturn();
std::cout << name << ' ' << n_moons << ' ' << rings << '\n'; 
```

**å¯å˜æ¨¡æ¿å‚æ•°åŒ…ä½¿ç¨‹åºå‘˜èƒ½å¤Ÿåˆ›å»ºå¯ä»¥æ¥å—ä»»æ„æ•°é‡å‚æ•°çš„æ¨¡æ¿å‡½æ•°ã€‚**

å‚æ•°åŒ…é€šè¿‡åœ¨ç±»å‹åç§°å‰é¢æ”¾ç½®ä¸‰ä¸ªç‚¹å’Œåœ¨å¯å˜å‚æ•°åé¢æ”¾ç½®ä¸‰ä¸ªç‚¹æ¥è¯†åˆ«ï¼Œç”¨é€—å·åˆ†éš”æ‰©å±•åŒ…ï¼š

```cpp
template<typename ...Ts> 
auto f(Ts... values) {
  g(values...);
}
```

### åŠ¨æ€å¤§å°çš„å¼‚æ„é›†åˆ

`std::any` `std::variant`

```cpp
// ä½¿ç”¨std::anyä½œä¸ºåŸºæœ¬ç±»å‹ã€‚
// ç¼ºç‚¹æ˜¯æ€§èƒ½ä¸å¥½ï¼š
//  æ¯æ¬¡è®¿é—®å…¶ä¸­çš„å€¼æ—¶ï¼Œå¿…é¡»åœ¨è¿è¡Œæ—¶æµ‹è¯•ç±»å‹ï¼Œç¼–è¯‘æ—¶å®Œå…¨å¤±å»äº†å­˜å‚¨å€¼çš„ç±»å‹ä¿¡æ¯ï¼›
//  åœ¨å †ä¸Šåˆ†é…å¯¹è±¡è€Œä¸æ˜¯æ ˆä¸Š
auto container = std::vector<std::any>(42, "hi", true);
```

[`std::variant`](https://en.cppreference.com/w/cpp/utility/variant.html)ï¼šThe class template std::variant represents a type-safe union.

* å®ƒä¸ä¼šå°†å…¶åŒ…å«çš„ç±»å‹å­˜å‚¨åœ¨å †ä¸Šï¼ˆä¸åƒstd::anyï¼‰
* å®ƒå¯ä»¥é€šè¿‡é€šç”¨ lambda è°ƒç”¨ï¼Œè¿™æ„å‘³ç€æ‚¨ä¸å¿…æ˜ç¡®çŸ¥é“å…¶å½“å‰åŒ…å«çš„ç±»å‹

```cpp
// ç”¨ std::holds_alternative<T>() æ¥æ£€æŸ¥å˜ä½“å½“å‰æ˜¯å¦æŒæœ‰ç»™å®šç±»å‹
using VariantType = std::variant<int, std::string, bool>; 
VariantType v{}; 
std::holds_alternative<int>(v);  // true, int is first alternative
v = 7; 
std::holds_alternative<int>(v);  // true
v = std::string{"Anne"};
std::holds_alternative<int>(v);  // false, int was overwritten 
v = false; 
std::holds_alternative<bool>(v); // true, v is now bool 
```

ç®€å•æ¥è¯´ï¼Œ`std::variant<T1, T2, ..., Tn>` çš„å¤§å°éµå¾ªï¼š`sizeof(std::variant) = æœ€å¤§sizeof(Ti) + åˆ¤åˆ«å™¨å¤§å° + å¯èƒ½çš„å¯¹é½å¡«å……`

#### std::variant çš„å¼‚å¸¸å®‰å…¨æ€§

`std::variant` çš„æ„é€ è¿‡ç¨‹å¯èƒ½å› å­˜å‚¨ç±»å‹çš„æ„é€ å‡½æ•°æŠ›å‡ºå¼‚å¸¸è€Œå¤±è´¥ã€‚æ­¤æ—¶ï¼š

- å¦‚æœåœ¨åˆå§‹åŒ–ç¬¬ä¸€ä¸ªï¼ˆæˆ–å”¯ä¸€ï¼‰å¯èƒ½çš„ç±»å‹æ—¶æŠ›å‡ºå¼‚å¸¸ï¼Œ`variant` ä¼šè¿›å…¥ **`valueless_by_exception` çŠ¶æ€**ï¼ˆä¸æŒæœ‰ä»»ä½•æœ‰æ•ˆå€¼ï¼‰ã€‚
- è¿™ç§çŠ¶æ€æ˜¯å®‰å…¨çš„ï¼š`variant` å¯¹è±¡æœ¬èº«ä»å¯æ­£å¸¸ææ„ï¼Œä¸ä¼šå¯¼è‡´èµ„æºæ³„æ¼ï¼Œä¹Ÿä¸ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºã€‚
- ä¾‹ï¼š`std::variant<int, std::string> v("hello");` è‹¥ `std::string` çš„æ„é€ æŠ›å‡ºå¼‚å¸¸ï¼ˆå¦‚å†…å­˜åˆ†é…å¤±è´¥ï¼‰ï¼Œ`v` ä¼šè¿›å…¥ `valueless_by_exception` çŠ¶æ€ã€‚

å¯¹ `std::variant` è¿›è¡Œèµ‹å€¼ï¼ˆ`operator=`ï¼‰æˆ–ä¿®æ”¹ï¼ˆå¦‚ `emplace`ã€`swap`ï¼‰æ—¶ï¼Œå¼‚å¸¸å®‰å…¨å–å†³äºå…·ä½“æ“ä½œï¼š

- **`emplace` æ“ä½œ**ï¼š  
  ç›´æ¥åœ¨ `variant` å†…éƒ¨æ„é€ æ–°å€¼ä»¥æ›¿æ¢å½“å‰å€¼ã€‚è‹¥æ–°å€¼çš„æ„é€ å‡½æ•°æŠ›å‡ºå¼‚å¸¸ï¼š
  - è‹¥æ›¿æ¢å‰ `variant` å·²æŒæœ‰å€¼ï¼Œæ—§å€¼ä¼šè¢«é”€æ¯ï¼Œ`variant` è¿›å…¥ `valueless_by_exception` çŠ¶æ€ï¼ˆåŸºæœ¬å¼‚å¸¸å®‰å…¨ï¼šå¯¹è±¡çŠ¶æ€æœ‰æ•ˆä½†å¯èƒ½ä¸¢å¤±åŸæœ‰å€¼ï¼‰ã€‚
  - è‹¥ `variant` åŸæœ¬å°±æ˜¯ `valueless_by_exception` çŠ¶æ€ï¼Œå¼‚å¸¸åä»ä¿æŒè¯¥çŠ¶æ€ã€‚

- **èµ‹å€¼æ“ä½œï¼ˆ`operator=`ï¼‰**ï¼š  
  å½“èµ‹äºˆæ–°ç±»å‹æˆ–åŒç±»å‹å€¼æ—¶ï¼Œå®ç°é€šå¸¸é‡‡ç”¨â€œå¤åˆ¶-äº¤æ¢â€ç­–ç•¥ï¼š
  1. å…ˆæ„é€ ä¸€ä¸ªä¸´æ—¶ `variant` æŒæœ‰æ–°å€¼ï¼›
  2. è‹¥æ„é€ æˆåŠŸï¼Œä¸å½“å‰ `variant` äº¤æ¢çŠ¶æ€ï¼›
  3. è‹¥ä¸´æ—¶ `variant` æ„é€ å¤±è´¥ï¼Œå½“å‰ `variant` çŠ¶æ€ä¸å˜ï¼ˆ**å¼ºå¼‚å¸¸å®‰å…¨ä¿è¯**ï¼‰ã€‚

- **`swap` æ“ä½œ**ï¼š  
  äº¤æ¢ä¸¤ä¸ª `variant` çš„çŠ¶æ€ï¼Œé€šå¸¸æ˜¯ noexcept çš„ï¼ˆè‹¥å­˜å‚¨ç±»å‹çš„äº¤æ¢æ“ä½œ noexceptï¼‰ã€‚è‹¥äº¤æ¢è¿‡ç¨‹ä¸­æŠ›å‡ºå¼‚å¸¸ï¼ˆæå°‘å‘ç”Ÿï¼‰ï¼Œæ ‡å‡†æœªå¼ºåˆ¶è§„å®šçŠ¶æ€ï¼Œä½†å®è·µä¸­ä¼šä¿è¯ä¸¤ä¸ª `variant` å¤„äºæœ‰æ•ˆçŠ¶æ€ï¼ˆå¯èƒ½äº¤æ¢ä¸å®Œæ•´ï¼Œä½†æ— èµ„æºæ³„æ¼ï¼‰ã€‚

`valueless_by_exception` æ˜¯ `std::variant` ä¸“é—¨è®¾è®¡çš„â€œå®‰å…¨æ— æ•ˆçŠ¶æ€â€ï¼Œç”¨äºåº”å¯¹æ„é€ /ä¿®æ”¹æ—¶çš„å¼‚å¸¸ï¼š

- å¯é€šè¿‡ `valueless_by_exception()` æ–¹æ³•æ£€æµ‹è¯¥çŠ¶æ€ã€‚
- å¤„äºè¯¥çŠ¶æ€çš„ `variant` ä»å¯æ­£å¸¸ææ„ï¼Œä¹Ÿå¯è¢«é‡æ–°èµ‹å€¼ä¸ºæœ‰æ•ˆçŠ¶æ€ã€‚
- è‹¥å¯¹è¯¥çŠ¶æ€çš„ `variant` è°ƒç”¨ `get<T>()` æˆ– `visit`ï¼Œä¼šæŠ›å‡º `std::bad_variant_access` å¼‚å¸¸ï¼ˆå±äºé¢„æœŸè¡Œä¸ºï¼Œè€Œéå®‰å…¨é—®é¢˜ï¼‰ã€‚


`std::variant` çš„ææ„å‡½æ•°å§‹ç»ˆå®‰å…¨ï¼š

- è‹¥æŒæœ‰æœ‰æ•ˆå€¼ï¼Œä¼šè°ƒç”¨å¯¹åº”ç±»å‹çš„ææ„å‡½æ•°é‡Šæ”¾èµ„æºã€‚
- è‹¥å¤„äº `valueless_by_exception` çŠ¶æ€ï¼Œææ„å‡½æ•°æ— æ“ä½œï¼ˆæ— éœ€é‡Šæ”¾èµ„æºï¼‰ã€‚
- æ— è®ºå“ªç§æƒ…å†µï¼Œéƒ½ä¸ä¼šå¯¼è‡´èµ„æºæ³„æ¼ã€‚

ä½¿ç”¨æ—¶éœ€æ³¨æ„æ£€æµ‹ `valueless_by_exception` çŠ¶æ€ï¼Œé¿å…å¯¹æ— æ•ˆçŠ¶æ€çš„ `variant` è¿›è¡Œè®¿é—®æ“ä½œã€‚

#### è®¿é—®å˜ä½“

è®¿é—®std::variantä¸­çš„å˜é‡æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€å‡½æ•°std::visit()ï¼Œé€šå¸¸é€šè¿‡ lambda æ¥è®¿é—®

```cpp
auto var = std::variant<int, bool, float>{};
std::visit([](auto&& val) { std::cout << val; }, var); 

// ä½¿ç”¨é€šç”¨ lambda å’Œå˜ä½“varè°ƒç”¨std::visit()æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°† lambda æ¦‚å¿µä¸Šè½¬æ¢ä¸ºä¸€ä¸ªå¸¸è§„ç±»
// è¯¥ç±»å¯¹å˜ä½“ä¸­çš„æ¯ç§ç±»å‹è¿›è¡Œoperator()é‡è½½ï¼Œç±»ä¼¼å¦‚ä¸‹ï¼š
struct GeneratedFunctorImpl {
  auto operator()(int&& v)   { std::cout << v; }
  auto operator()(bool&& v)  { std::cout << v; }
  auto operator()(float&& v) { std::cout << v; }
}; 

// std::visit()å‡½æ•°æ‰©å±•ä¸ºä½¿ç”¨std::holds_alternative<T>()çš„if...elseé“¾
// æˆ–ä½¿ç”¨std::variantçš„ç´¢å¼•ç”Ÿæˆæ­£ç¡®çš„è°ƒç”¨std::get<T>()çš„è·³è½¬è¡¨ã€‚
```

#### å…¨å±€å‡½æ•° `std::get()`

å…¨å±€å‡½æ•°æ¨¡æ¿`std::get()`å¯ç”¨äº`std::tuple`ã€`std::pair`ã€`std::variant`å’Œ`std::array`ã€‚æœ‰ä¸¤ç§å®ä¾‹åŒ–std::get()çš„æ–¹å¼ï¼Œä¸€ç§æ˜¯ä½¿ç”¨ç´¢å¼•ï¼Œä¸€ç§æ˜¯ä½¿ç”¨ç±»å‹ï¼š

* `std::get<Index>()`: å½“`std::get()`ä¸ç´¢å¼•ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œå¦‚`std::get<1>(v)`ï¼Œå®ƒè¿”å›std::tupleã€std::pairæˆ–std::arrayä¸­ç›¸åº”ç´¢å¼•å¤„çš„å€¼ã€‚

* `std::get<Type>()`: å½“`std::get()`ä¸ç±»å‹ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œå¦‚`std::get<int>(v)`ï¼Œè¿”å›std::tupleã€std::pairæˆ–std::variantä¸­çš„ç›¸åº”å€¼ã€‚å¯¹äºstd::variantï¼Œå¦‚æœå˜ä½“å½“å‰ä¸æŒæœ‰è¯¥ç±»å‹ï¼Œåˆ™ä¼šæŠ›å‡ºstd::bad_variant_accesså¼‚å¸¸ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœvæ˜¯std::tupleï¼Œå¹¶ä¸”TypeåŒ…å«å¤šæ¬¡ï¼Œåˆ™å¿…é¡»ä½¿ç”¨ç´¢å¼•æ¥è®¿é—®è¯¥ç±»å‹ã€‚

## 10. ä»£ç†å¯¹è±¡å’Œå»¶è¿Ÿè¯„ä¼°

> Proxy Objects and Lazy Evaluation

First and foremost, the techniques used in this chapter are used to hide optimizations in a library from the user of that library. This is useful because exposing every single optimization technique as a separate function requires a lot of attention and education from the user of the library. It also bloats the code base with a multitude of specific functions, making it hard to read and understand. By using proxy objects, we can achieve optimizations under the hood; the resultant code is both optimized and readable.

**Lazy evaluation** is a technique used to postpone an operation until its result is really needed. The opposite, where operations are performed right away, is called **eager evaluation**.

* å»¶è¿Ÿæ‰§è¡Œï¼šæ‰€æœ‰è®¡ç®—ä»…åœ¨å¿…è¦æ—¶è§¦å‘ï¼ˆå¦‚æ¯”è¾ƒã€èµ‹å€¼ï¼‰ï¼Œé¿å…æå‰æ¶ˆè€—èµ„æºã€‚
* é›¶é¢å¤–å¼€é”€ï¼šä»£ç†å¯¹è±¡ä»…å­˜å‚¨å¼•ç”¨æˆ–æŒ‡é’ˆï¼Œä¸å¤åˆ¶åŸå§‹æ•°æ®ï¼Œç¬¦åˆ â€œé›¶æˆæœ¬æŠ½è±¡â€ åŸåˆ™ã€‚
* è¯­æ³•é€æ˜æ€§ï¼šé€šè¿‡è¿ç®—ç¬¦é‡è½½ä½¿ä»£ç†å¯¹è±¡çš„ä½¿ç”¨æ–¹å¼ä¸åŸå§‹å¯¹è±¡ä¸€è‡´ï¼Œä¸ç ´åä»£ç å¯è¯»æ€§ã€‚

ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š

```cpp
class Image { /* ... */ };                   // Buffer with JPG data
auto load(std::string_view path) -> Image;   // Load image at path
class ScoreView {
public:
  // Eager, requires loaded bonus image
  void display(const Image& bonus);
  // Lazy, only load bonus image if necessary
  void display(std::function<Image()> bonus);
  // ...
}; 

// Always load bonus image eagerly
const auto eager = load("/images/stars.jpg");
score.display(eager); 

// Load default image lazily if needed
auto lazy = [] { return load("/images/stars.jpg"); }; 
score.display(lazy); 
```

A technique for hiding the fact that the code evaluates lazily is to use **proxy objects**.

### ä½¿ç”¨ä»£ç†å¯¹è±¡çš„ä¸€äº›ä¾‹å­

1. é€šè¿‡ä»£ç†å¯¹è±¡å»¶è¿Ÿå­—ç¬¦ä¸²æ‹¼æ¥æ“ä½œï¼Œé¿å…åˆ›å»ºä¸´æ—¶å¯¹è±¡ä»¥æå‡æ€§èƒ½ã€‚

```cpp
class StringProxy {
private:
    const std::string& left_;
    const std::string& right_;
public:
    StringProxy(const std::string& l, const std::string& r) : left_(l), right_(r) {}

    // å»¶è¿Ÿæ‹¼æ¥ï¼Œä»…åœ¨éœ€è¦æ—¶æ‰§è¡Œ
    operator std::string() const {
        return left_ + right_;
    }

    // é‡è½½æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œç›´æ¥æ“ä½œåŸå§‹å­—ç¬¦ä¸²é¿å…æ‹¼æ¥
    bool operator==(const std::string& other) const {
        if (left_.size() + right_.size() != other.size()) return false;
        return other.substr(0, left_.size()) == left_ &&
               other.substr(left_.size()) == right_;
    }
};

// ä½¿ç”¨ç¤ºä¾‹
std::string a = "Hello", b = "World";
StringProxy proxy(a, b);
if (proxy == "HelloWorld") {  // ä¸è§¦å‘æ‹¼æ¥ï¼Œç›´æ¥æ¯”è¾ƒ
    std::string s = proxy;    // æ­¤æ—¶æ‰æ‰§è¡Œæ‹¼æ¥
}
```

2. äºŒç»´å‘é‡é•¿åº¦æ¯”è¾ƒåœºæ™¯ï¼Œé€šè¿‡LengthProxyå»¶è¿Ÿsqrtè®¡ç®—ï¼Œä»…åœ¨å¿…è¦æ—¶æ‰§è¡Œ

```cpp
class Vector2D {
private:
    float x_, y_;
public:
    Vector2D(float x, float y) : x_(x), y_(y) {}

    // è¿”å›ä»£ç†å¯¹è±¡è€Œéç›´æ¥è®¡ç®—é•¿åº¦
    class LengthProxy {
    private:
        const Vector2D& vec_;
    public:
        LengthProxy(const Vector2D& v) : vec_(v) {}

        // å»¶è¿Ÿè®¡ç®—ï¼šä»…åœ¨æ¯”è¾ƒæ—¶æ‰§è¡Œsqrt
        bool operator<(const LengthProxy& other) const {
            // æ¯”è¾ƒå¹³æ–¹å€¼ä»¥é¿å…sqrtï¼Œè¿›ä¸€æ­¥ä¼˜åŒ–
            return (vec_.x_ * vec_.x_ + vec_.y_ * vec_.y_) <
                   (other.vec_.x_ * other.vec_.x_ + other.vec_.y_ * other.vec_.y_);
        }
    };

    LengthProxy length() const { return LengthProxy(*this); }
};

// ä½¿ç”¨ç¤ºä¾‹
Vector2D v1(3, 4), v2(1, 2);
if (v1.length() < v2.length()) {  // ä¸è®¡ç®—sqrtï¼Œç›´æ¥æ¯”è¾ƒå¹³æ–¹å’Œ
    // ...
}
```

3. åˆ©ç”¨ä»£ç†å¯¹è±¡å’Œè¿ç®—ç¬¦é‡è½½å®ç°ç±»ä¼¼ â€œæ‰©å±•æ–¹æ³•â€ çš„é“¾å¼è°ƒç”¨

```cpp
// ä»£ç†ç±»ï¼šåŒ…è£…å€¼å¹¶æ”¯æŒç®¡é“æ“ä½œ
template <typename T>
class PipeProxy {
private:
    T value_;
public:
    PipeProxy(T val) : value_(std::move(val)) {}

    // é‡è½½ç®¡é“è¿ç®—ç¬¦ï¼Œæ¥æ”¶å‡½æ•°å¹¶è¿”å›æ–°ä»£ç†
    template <typename F>
    auto operator|(F&& func) const {
        return PipeProxy<std::invoke_result_t<F, T>>(func(value_));
    }

    // æå–æœ€ç»ˆå€¼
    const T& get() const { return value_; }
};

// ç¤ºä¾‹å‡½æ•°ï¼šå­—ç¬¦ä¸²å¤„ç†
std::string to_upper(const std::string& s) {
    std::string res = s;
    std::transform(res.begin(), res.end(), res.begin(), ::toupper);
    return res;
}

std::string trim(const std::string& s) {
    auto start = s.begin();
    while (start != s.end() && std::isspace(*start)) start++;
    auto end = s.end();
    while (end != start && std::isspace(*(end-1))) end--;
    return std::string(start, end);
}

// ä½¿ç”¨ç¤ºä¾‹
std::string s = "  hello world  ";
auto result = PipeProxy(s) | trim | to_upper;  // é“¾å¼è°ƒç”¨
std::cout << result.get();  // è¾“å‡º "HELLO WORLD"
```

## 11. å¹¶å‘

### å¹¶å‘å’Œå¹¶è¡Œ

å¹¶å‘ï¼ˆConcurrencyï¼‰

* **ä»»åŠ¡æ‰§è¡Œæ–¹å¼** ï¼šå¤šä¸ªä»»åŠ¡åŒæ—¶å¤„äºæ‰§è¡ŒçŠ¶æ€ï¼Œä½†å®ƒä»¬å¯èƒ½å¹¶ä¸æ˜¯åŒæ—¶åœ¨ç‰©ç†ä¸Šæ‰§è¡Œã€‚åœ¨å•æ ¸å¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡å¿«é€Ÿåˆ‡æ¢ä»»åŠ¡ï¼ˆæ—¶é—´ç‰‡è½®è½¬ï¼‰æ¥è®©å¤šä¸ªåŠ¡äº¤æ›¿æ‰§è¡Œï¼Œç»™äººä»¥åŒæ—¶æ‰§è¡Œçš„é”™è§‰ã€‚
* **å…³æ³¨é‡ç‚¹** ï¼šåœ¨äºè®©å¤šä¸ªä»»åŠ¡åŒæ—¶è¿›è¡Œï¼Œå……åˆ†åˆ©ç”¨ç³»ç»Ÿèµ„æºï¼Œæé«˜æ•´ä½“æ•ˆç‡ï¼Œå¼ºè°ƒçš„æ˜¯ä»»åŠ¡çš„æ‰§è¡Œæ–¹å¼å’Œè°ƒåº¦æœºåˆ¶ã€‚
* **å®ç°æ–¹å¼** ï¼šå¯ä»¥é€šè¿‡å¤šçº¿ç¨‹ã€è¿›ç¨‹é—´é€šä¿¡ã€åç¨‹ç­‰æ–¹å¼æ¥å®ç°ï¼Œä¸ä¾èµ–ç¡¬ä»¶çš„å¤šæ ¸æ”¯æŒã€‚
* **æ€§èƒ½æå‡** ï¼šåœ¨å•æ ¸ä¸Šå¹¶å‘æ‰§è¡Œä»»åŠ¡ä¸ä¸€å®šèƒ½æé«˜æ‰§è¡Œé€Ÿåº¦ï¼Œç”šè‡³å¯èƒ½å› ä¸ºä»»åŠ¡åˆ‡æ¢å¼€é”€è€Œå˜æ…¢ï¼Œä½†åœ¨å¤šæ ¸ç¯å¢ƒä¸‹å¯ä»¥æå‡æ•ˆç‡ã€‚
* **é€‚ç”¨åœºæ™¯** ï¼šé€‚ç”¨äº I/O å¯†é›†å‹ä»»åŠ¡ï¼Œå¦‚ç½‘ç»œè¯·æ±‚ã€æ–‡ä»¶è¯»å†™ç­‰ï¼Œä»»åŠ¡ç­‰å¾…æ—¶é—´é•¿ï¼Œé€šè¿‡å¹¶å‘å¯ä»¥æé«˜èµ„æºåˆ©ç”¨ç‡ã€‚

å¹¶è¡Œï¼ˆParallelismï¼‰

* **ä»»åŠ¡æ‰§è¡Œæ–¹å¼** ï¼šå¤šä¸ªä»»åŠ¡åŒæ—¶åœ¨å¤šä¸ªå¤„ç†å™¨æˆ–æ ¸å¿ƒä¸ŠåŒæ—¶æ‰§è¡Œï¼ŒçœŸæ­£åˆ©ç”¨äº†å¤šæ ¸ç¡¬ä»¶èµ„æºæ¥åŠ é€Ÿä»»åŠ¡æ‰§è¡Œã€‚
* **å…³æ³¨é‡ç‚¹** ï¼šåœ¨äºä»»åŠ¡çš„åˆ†è§£å’ŒåŒæ—¶æ‰§è¡Œï¼Œä»¥å‡å°‘å®Œæˆä»»åŠ¡æ‰€éœ€çš„æ—¶é—´ï¼Œå¼ºè°ƒçš„æ˜¯ä»»åŠ¡çš„å®é™…åŒæ—¶æ‰§è¡Œå’Œè®¡ç®—èƒ½åŠ›çš„æå‡ã€‚
* **å®ç°æ–¹å¼** ï¼šä¾èµ–äºå¤šæ ¸å¤„ç†å™¨æˆ–å¤šä¸ªè®¡ç®—èŠ‚ç‚¹ï¼Œåœ¨æ¯ä¸ªå¤„ç†å™¨æˆ–æ ¸å¿ƒä¸Šåˆ†é…å­ä»»åŠ¡åŒæ—¶æ‰§è¡Œã€‚
* **æ€§èƒ½æå‡** ï¼šèƒ½å……åˆ†åˆ©ç”¨å¤šæ ¸ç¡¬ä»¶èµ„æºï¼Œæ˜¾è‘—æé«˜ä»»åŠ¡æ‰§è¡Œé€Ÿåº¦ï¼Œç†è®ºä¸Šæ€§èƒ½æå‡ä¸å¤„ç†å™¨æ ¸å¿ƒæ•°æˆæ­£æ¯”ã€‚
* **é€‚ç”¨åœºæ™¯** ï¼šé€‚ç”¨äºè®¡ç®—å¯†é›†å‹ä»»åŠ¡ï¼Œå¦‚ç§‘å­¦è®¡ç®—ã€å¤§æ•°æ®å¤„ç†ç­‰ï¼Œéœ€è¦å¤§é‡è®¡ç®—èµ„æºï¼Œé€šè¿‡å¹¶è¡Œå¯ä»¥å¿«é€Ÿå¾—åˆ°ç»“æœã€‚

#### å…±äº«å†…å­˜

#### æ•°æ®ç«äº‰

é¿å…æ•°æ®ç«äº‰ï¼š

* ä½¿ç”¨åŸå­æ•°æ®ç±»å‹è€Œä¸æ˜¯intã€‚è¿™å°†å‘Šè¯‰ç¼–è¯‘å™¨ä»¥åŸå­æ–¹å¼æ‰§è¡Œè¯»å–ã€å¢åŠ å’Œå†™å…¥ã€‚æˆ‘ä»¬å°†åœ¨æœ¬ç« åé¢èŠ±æ›´å¤šæ—¶é—´è®¨è®ºåŸå­æ•°æ®ç±»å‹ã€‚

* ä½¿ç”¨äº’æ–¥é”ï¼ˆmutexï¼‰æ¥ä¿è¯å¤šä¸ªçº¿ç¨‹æ°¸è¿œä¸ä¼šåŒæ—¶æ‰§è¡Œå…³é”®éƒ¨åˆ†ã€‚å…³é”®éƒ¨åˆ†æ˜¯ä»£ç ä¸­ä¸å¾—åŒæ—¶æ‰§è¡Œçš„åœ°æ–¹ï¼Œå› ä¸ºå®ƒæ›´æ–°æˆ–è¯»å–å¯èƒ½ä¼šäº§ç”Ÿæ•°æ®ç«äº‰çš„å…±äº«å†…å­˜ã€‚

#### äº’æ–¥é”å’Œä¸´ç•ŒåŒº

äº’æ–¥é”ï¼Œæ˜¯ç”¨äºé¿å…æ•°æ®ç«äº‰çš„åŒæ­¥åŸè¯­ã€‚éœ€è¦è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹é¦–å…ˆéœ€è¦é”å®šäº’æ–¥é”

#### æ­»é”

ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«èµ„æºæ—¶ï¼Œå­˜åœ¨é™·å…¥æ­»é”çŠ¶æ€çš„é£é™©ã€‚å½“ä¸¤ä¸ªçº¿ç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹é‡Šæ”¾é”æ—¶ï¼Œå°±ä¼šå‘ç”Ÿæ­»é”ã€‚

### å¹¶å‘ç¼–ç¨‹

```cpp
std::this_thread::get_id();  // è·å–çº¿ç¨‹æ ‡è¯†ç¬¦

std::this_thread::sleep_for(std::chrono::seconds{1});  // çº¿ç¨‹ä¼‘çœ 

std::thread::hardware_concurrency(); // ç¡¬ä»¶çº¿ç¨‹çš„æ€»æ•°
```

[**C++20 `jthread`**](https://en.cppreference.com/w/cpp/thread/jthread.html)

C++20 å¼•å…¥äº† `std::jthread`ï¼Œå®ƒæ˜¯ä¸€ç§æ›´æ™ºèƒ½çš„çº¿ç¨‹ç®¡ç†æ–¹å¼ï¼Œè§£å†³äº† `std::thread` åœ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†å’Œçº¿ç¨‹å–æ¶ˆæ–¹é¢çš„ä¸è¶³ã€‚

`std::jthread` å¯¹è±¡åœ¨è¢«é”€æ¯æ—¶ä¼šè‡ªåŠ¨è°ƒç”¨ `join()` æ–¹æ³•ï¼Œç¡®ä¿åœ¨å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶ï¼Œå…³è”çš„çº¿ç¨‹ä¼šå®Œæˆæˆ–ç»ˆæ­¢ã€‚è¿™é¿å…äº†æ‰‹åŠ¨è°ƒç”¨ `join` æˆ– `detach` çš„éº»çƒ¦ï¼Œä»¥åŠå¯èƒ½å¼•å‘çš„èµ„æºæ³„æ¼é—®é¢˜ã€‚

```cpp
std::jthread jthr{[]{std::this_thread::sleep_for(std::chrono::seconds(1));}};
// jthr è‡ªåŠ¨ joinï¼Œæ— éœ€æ‰‹åŠ¨è°ƒç”¨
```

`std::jthread` ä¸ `std::stop_source` å’Œ `std::stop_token` ç´§å¯†é›†æˆï¼Œå…è®¸å¤–éƒ¨è¯·æ±‚çº¿ç¨‹åœæ­¢ã€‚çº¿ç¨‹å‡½æ•°å¯ä»¥é€šè¿‡æ£€æŸ¥ `std::stop_token` çš„çŠ¶æ€æ¥ä¼˜é›…åœ°åœæ­¢æ‰§è¡Œã€‚

```cpp
auto stop_source = std::stop_source{};
std::jthread jthr{[&]{ 
    std::stop_token stok = stop_source.get_token();
    while (!stok.stop_requested()) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}}; 
stop_source.request_stop(); // å¤–éƒ¨è¯·æ±‚çº¿ç¨‹åœæ­¢
```

**ä½¿ç”¨`std::mutex`ä¿æŠ¤å…³é”®éƒ¨åˆ†**

```cpp
#include <mutex>
#include <thread>
#include <cassert>

std::mutex counter_mutex; // ç”¨äºä¿æŠ¤counterçš„äº’æ–¥é”
int counter = 0;

void increment_counter(int n) {
    for (int i = 0; i < n; ++i) {
        std::lock_guard<std::mutex> lock(counter_mutex); // è‡ªåŠ¨ç®¡ç†é”
        ++counter;
    }
}
```

**é¿å…æ­»é”ï¼Œæ­»é”æ˜¯æŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹å› ä¸ºç­‰å¾…å¯¹æ–¹é‡Šæ”¾èµ„æºè€Œæ— æ³•ç»§ç»­æ‰§è¡Œçš„æƒ…å†µã€‚ä¸ºäº†é¿å…æ­»é”ï¼Œå¯ä»¥ä½¿ç”¨std::lock()å‡½æ•°åŒæ—¶é”å®šå¤šä¸ªäº’æ–¥é”**

```cpp
#include <mutex>

struct Account {
    int balance_ = 0;
    std::mutex m_;
};

void transfer_money(Account& from, Account& to, int amount) {
    std::unique_lock<std::mutex> lock1(from.m_, std::defer_lock);
    std::unique_lock<std::mutex> lock2(to.m_, std::defer_lock);
    std::lock(lock1, lock2);

    from.balance_ -= amount;
    to.balance_ += amount;
}
```

**ä½¿ç”¨æ¡ä»¶å˜é‡åè°ƒçº¿ç¨‹**

```cpp
#include <condition_variable>
#include <queue>
#include <thread>

std::condition_variable cv;
std::queue<int> q;
std::mutex mtx; // ä¿æŠ¤å…±äº«é˜Ÿåˆ—
const int sentinel = -1;

void print_ints() {
    int i = 0;
    while (i != sentinel) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [] { return !q.empty(); });
        i = q.front();
        q.pop();
        if (i != sentinel) {
            std::cout << "Got: " << i << '\n';
        }
    }
}

void generate_ints() {
    for (int i : {1, 2, 3, sentinel}) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::lock_guard<std::mutex> lock(mtx);
        q.push(i);
        cv.notify_one();
    }
}

int main() {
    std::jthread producer(generate_ints);
    std::jthread consumer(print_ints);
}
```

**ä½¿ç”¨`std::future`å’Œ`std::promise`å¤„ç†è¿”å›å€¼å’Œé”™è¯¯**

```cpp
#include <exception>
#include <future>
#include <iostream>

std::promise<int> p;

void divide(int a, int b) {
    if (b == 0) {
        std::runtime_error e("Divide by zero exception");
        p.set_exception(std::make_exception_ptr(e));
    } else {
        int result = a / b;
        p.set_value(result);
    }
}

int main() {
    std::thread(divide, 45, 5).detach();
    std::future<int> f = p.get_future();
    try {
        const int& result = f.get();
        std::cout << "Result: " << result << '\n';
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << '\n';
    }
}
```

`std::packaged_task`æ˜¯ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼Œå®ƒå¯ä»¥è‡ªåŠ¨åˆ›å»º`std::promise`å’Œ`std::future`

```cpp
#include <future>
#include <iostream>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Divide by zero exception");
    }
    return a / b;
}

int main() {
    std::packaged_task<int(int, int)> task(divide);
    std::future<int> f = task.get_future();
    std::thread(std::move(task), 45, 5).detach();

    try {
        const int& result = f.get();
        std::cout << "Result: " << result << '\n';
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << '\n';
    }
}
```

`std::async`æ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œå¯ä»¥è‡ªåŠ¨åˆ›å»º`std::packaged_task`å’Œ`std::thread`

```cpp
#include <future>
#include <iostream>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Divide by zero exception");
    }
    return a / b;
}

int main() {
    std::future<int> f = std::async(divide, 45, 5);
    try {
        const int& result = f.get();
        std::cout << "Result: " << result << '\n';
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << '\n';
    }
}
```

#### C++20ä¸­çš„åŒæ­¥åŸè¯­

è¯¦è§ [C++20 Additional synchronization primitives]()