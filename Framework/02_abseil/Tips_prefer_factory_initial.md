
在不允许使用异常的C++环境（如谷歌内部），推荐优先使用**工厂函数（Factory Functions）** 替代**初始化方法（Initializer Methods）**，以解决对象初始化失败的优雅处理问题，同时避免多状态类带来的可维护性风险。

1. **背景：构造函数的局限**
   - C++构造函数在禁用异常的环境中无法向调用者报告初始化失败，仅能通过`abort()`崩溃程序，这在生产代码中通常不可接受。
   - 若类的初始化逻辑存在失败可能，传统方案是提供“初始化方法”（init方法），通过返回值标识失败，用户需在构造后立即调用该方法。

2. **初始化方法的核心问题**
   - 类需维护多状态：至少包含“未初始化”“已初始化”“初始化失败”三种用户可见状态，每个方法都需明确支持的调用状态，用户易违规（如初始化前调用其他方法、失败后继续使用）。
   - 可维护性差：一旦用户依赖非预期的预初始化调用组合（遵循Hyrum定律），类的实现会被绑定为“隐性接口”，后续迭代难度剧增。

3. **工厂函数的优势与实现**
   - **核心设计**：提供静态工厂函数（如`Foo::Create()`），统一负责对象的创建与初始化，通过返回指针（如`std::unique_ptr`）或`absl::optional`（null表示失败）向调用者反馈结果。
   - **优势**：
     1. 仅暴露完全初始化的有效对象，兼顾构造函数的“对象完整性”与初始化方法的“失败反馈”；
     2. 可灵活返回返回类型的任意子类实例，支持动态切换实现（不改动用户代码）；
     3. 避免多状态类的设计复杂度。
   - **示例代码结构**：类的构造函数设为私有（禁止用户直接实例化），工厂函数通过`new`创建对象后，用`absl::WrapUnique`包装为智能指针返回。

4. **工厂函数的局限性**
   - 仅适用于堆分配对象（返回指针），不适合设计为栈上使用的“值类型”类（这类类通常无需复杂初始化）；
   - 当派生类构造函数需初始化基类时，工厂函数无法使用，此时基类的受保护API可能仍需初始化方法，但公共API仍可保留工厂函数设计。

## Ref

- [Tip of the Week #42: Prefer Factory Functions to Initializer Methods](https://abseil.io/tips/42)