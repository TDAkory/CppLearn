# Tips of Optimization

## Optimizing for application productivity

本文是Google发布的性能优化技巧系列第7篇，核心主题是**以“应用生产力”为核心进行优化**，而非依赖传统资源消耗或指令相关指标。

### 核心背景与核心指标

- Google服务器集群的核心目标是完成“有用工作”（如处理搜索查询、转码视频等），而非单纯降低资源消耗（如CPU占用、内存分配耗时）。
- 单纯的资源消耗指标（如CPU使用率上升）无法区分“工作负载增加”（如处理更多视频）和“效率下降”（如无用的协议转换），因此需要**应用生产力指标（APMs）** ——即每单位资源（CPU秒、内存字节秒、磁盘操作、硬件加速器时间）完成的实际工作总量（如处理的视频数量），以此衡量优化价值。

### 传统指标的局限性（需APMs补充的场景）

传统指标（如MIPS、IPC、组件相对耗时）无法准确反映以下关键优化的价值，甚至可能误导决策：

1. **核心基础设施变更优化**
   - TCMalloc的大页感知分配器（Temeraire）：虽增加了TCMalloc自身的相对耗时，但通过优化数据布局提升了整体应用性能，属于正向优化。
   - Protocol Buffer的Arenas分配：不仅加速了协议缓冲区代码（如消息析构），还优化了业务逻辑的数据局部性，使主流框架每CPU能多处理15-30%的工作。
2. **新指令集应用**
   - 新硬件指令（如`rep movsb`、AVX、FMA、BMI）虽可能降低MIPS（每秒百万指令数）或IPC（每周期指令数），但单指令能完成更多工作（如`rep movsb`替代复制循环），实际提升处理效率。例如，用`--march=haswell`编译启用新指令集时，虽MIPS下降，但查询耗时减少、QPS提升。
3. **编译器优化**
   - 内联等优化会减少动态执行的指令数，虽降低“指令总量”相关指标，但简化了代码并加速执行，提升生产力。
4. **内核优化**
   - 调整大页策略、线程调度等内核参数可能增加内核自身开销（如内存压缩工作量），但应用层面的收益远大于这些成本。

### 核心结论

- 应用生产力指标（APMs）是衡量优化价值的关键，能帮助团队识别传统指标无法覆盖的有效优化。
- 优化的核心目标是“提升单位资源的有用工作量”，而非单纯降低某一组件的耗时或提升指令相关指标，这一导向能更高效地优化Google服务器集群的整体效率。

## Optimizations past their prime

本文核心观点为：优化并非一劳永逸，过去针对旧平台（如Intel Pentium 3、AMD Opterons）的合理优化，随着硬件迭代与编译器发展，可能逐渐沦为性能负担。文章通过两个具体案例展开，并给出长期有效的优化实践建议。

### 1. Popcount指令相关优化

- 背景：2008年Intel引入`popcnt`指令（用于统计整数中置1位的数量），Google相关库提供两个实现：`CountOnes64`（运行时检测指令可用性，支持则使用，否则降级）和`CountOnes64withPopcount`（x86_64平台无条件通过内联汇编使用`popcnt`）。
- 问题：随着硬件普及，所有x86_64机器均支持`popcnt`指令，但`CountOnes64`的运行时检测开销仍存在；且内联汇编会阻止编译器规避部分处理器的假依赖bug，而使用编译器内建函数的`CountOnes64`反而能生成更优机器码，导致原本旨在选“快实现”的运行时调度，实际选择了更慢的版本。

### 2. CHECK_EQ宏优化

- 背景：2005年Google基于`CheckOpString`（`std::string*`的轻量包装）实现`CHECK`日志宏，后续添加了编译器优化提示（预测比较结果大概率为真）。
- 问题：LLVM编译时会产生冗余检查——先判断`a == b`（预测为真），再判断`str_ != nullptr`（预测为假），但`a == b`为真时`str_`必然是`nullptr`，冗余分支源于多年累积的代码复杂度；而调试版本早在2008年就已移除`CheckOpString`，优化版本后续移除该包装后，直接使用`std::string*`，消除了冗余开销。

### 最佳实践建议

1. 优先编写清晰、符合语言习惯的代码：不仅便于阅读和调试，长期来看也更易被编译器优化。
2. 谨慎使用低层级优化：对于位操作、 intrinsics 代码、内联汇编等低层级优化，先判断编译器是否能自主实现；若必须使用，按“便携性优先级”选择（hwy生成便携向量代码→intrinsics→内联汇编，内联汇编应极罕见），避免降低代码跨架构兼容性。
3. 保留参考实现：优化时不要删除被替换的“朴素”代码，可将其作为参考函数（如`REFERENCE_ComputeFoo`），方便后续单元测试（验证功能一致性）、微基准测试和必要时回滚。
4. 附带微基准测试：优化变更需搭配对应的微基准测试，确保优化效果。
5. 合理设计配置项：配置项应基于“预期结果”而非“具体行为”设计，避免固定过时的默认逻辑，确保配置能随环境变化持续保持最优。

## Ref

- [Performance Tip of the Week #7: Optimizing for application productivity](https://abseil.io/fast/7)
- [Performance Tip of the Week #9: Optimizations past their prime](https://abseil.io/fast/9)
