
文档核心观点为：**不建议在生产代码（尤其库代码）中使用标志位（Flags）**，仅在极少数必要场景下可谨慎使用，同时提供了更优的替代方案。

1. **标志位的本质与核心问题**
   - 标志位本质是“更糟的全局变量”：其值无法通过代码静态预测，可能在启动后通过任意方式动态修改，且无变更通知、变更日志记录不完整，服务器运行中甚至无法保证标志位值的稳定性。
   - 具体问题：
     1. 不确定性高：库代码中无法判断某功能是否因标志位未被使用而失效，难以清理冗余功能；
     2. 阻碍死代码清理：若遗留代码中存在大量生产环境引用的标志位，删除旧代码会导致二进制文件启动失败，给发布工程师带来极大麻烦；
     3. 多数标志位无实际意义：谷歌2012年初的分析显示，绝大多数C++标志位在数据留存周期内从未发生过值变更，没必要通过标志位控制。

2. **标志位的合理适用场景**
   - 调试场景：支持标志位的回溯功能对调试至关重要；
   - 功能标志位：处理得当且后续及时清理的功能标志位（如灰度发布、特性切换）；
   - 应急控制旋钮：供SRE（站点可靠性工程师）紧急调整的系统参数（安全兜底）；
   - 二进制输入：仅在`main()`函数中用于传递名值对输入，比位置参数更易维护。

3. **替代方案与实践建议**
   - 显式传递配置：优先通过显式参数传递配置，更易推理逻辑、降低维护成本；
   - 编译时常量：将数值型标志位改为编译时常量，避免运行时不确定性；
   - 严格审查：代码审查中对新增标志位提出质疑，要求每个标志位的引入都必须提供正当理由，避免滥用。

## Ref

- [Tip of the Week #45: Avoid Flags, Especially in Library Code](https://abseil.io/tips/45)