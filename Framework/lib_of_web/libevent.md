# [libevent](https://libevent.org/)

- [libevent](#libevent)
	- [参考资料](#参考资料)
	- [源码分析笔记](#源码分析笔记)
		- [跨平台配置生成](#跨平台配置生成)
		- [通用类型支持](#通用类型支持)
		- [日志支持](#日志支持)
		- [内存处理](#内存处理)
			- [注意事项](#注意事项)
		- [多线程支持](#多线程支持)
			- [锁结构](#锁结构)
			- [锁类型](#锁类型)
			- [锁模式](#锁模式)
			- [多平台支持](#多平台支持)
			- [定制顺序](#定制顺序)
			- [Debug支持](#debug支持)
		- [容器](#容器)
			- [tail queues](#tail-queues)

## 参考资料

> [libevent深入浅出](https://github.com/aceld/libevent)
> [libevent源码深度剖析](https://github.com/luodw/Material/blob/master/libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90.pdf)

## 源码分析笔记

基于`release-2.1.12-stable`

### 跨平台配置生成

`event-config.h`

```cpp
/* event2/event-config.h
 *
 * This file was generated by autoconf when libevent was built, and post-
 * processed by Libevent so that its macros would have a uniform prefix.
 *
 * DO NOT EDIT THIS FILE.
 *
 * Do not rely on macros in this file existing in later versions.
 */
#ifndef EVENT_CONFIG_H__
#define EVENT_CONFIG_H__
/* config.h.  Generated by configure.  */
/* config.h.in.  Generated from configure.in by autoheader.  */
```

`event-config.h`这个文件并不是一直不变的，这里有一个过程：

* 首先，configure在检查环境依赖的时候会生成config.h和Makefile;
* 然后，Makefile会根据config.h生成event-config.h;

文件中的宏定义，对代码运行环境进行了详细的检查，包括是否包含特定的头文件，libc库是否包含特定的函数，是否声明了某些特定名字的结构体，支持哪些IO多路复用机制等等，举例：

```cpp
/* Define to 1 if you have the <dlfcn.h> header file. */
#define EVENT__HAVE_DLFCN_H 1
/* Define if your system supports the epoll system calls */
#define EVENT__HAVE_EPOLL 1
/* Define to 1 if you have the `epoll_create1' function. */
/* #undef EVENT__HAVE_EPOLL_CREATE1 */
/* Define to 1 if you have the `epoll_ctl' function. */
#define EVENT__HAVE_EPOLL_CTL 1
/* Define to 1 if you have the <errno.h> header file. */
#define EVENT__HAVE_ERRNO_H 1
```

### 通用类型支持

Libevent定义了一系列的可移植的兼容类型和函数。这使得在各个系统上都有一致的效果，Libevent一般都会在兼容通用类型和函数的前面加上ev或evutil前缀。

在实现上，Libevent都是使用条件编译+宏定义的方式。使用这种方式，同一个宏名字，可以使得在不同的系统上， 编译时得到不同的值。这种方式在跨平台编程中，经常使用到。此外，对于Libevent的兼容类型，如果所在系统已经有对应功能的类型，那么Libevent将直接将ev_XXX宏的值定义为该类型。如果所在系统没有对应的类型，那么就会选择一个比较合理的类型作为宏值。

### 日志支持

主要实现在`log.c`文件中。默认行为是输出到控制台，同时支持用户设置日志回调`event_set_log_callback`;

内部使用的日志接口定义在`log-internal.h`;

```cpp
/**
  A callback function used to intercept Libevent's log messages.

  @see event_set_log_callback
 */
typedef void (*event_log_cb)(int severity, const char *msg);


static event_log_cb log_fn = NULL;

void
event_set_log_callback(event_log_cb cb)
{
	log_fn = cb;
}

static void
event_log(int severity, const char *msg)
{
	if (log_fn)
		log_fn(severity, msg);
	else {
		const char *severity_str;
		switch (severity) {
		... // different severity
		}
        // output to console
		(void)fprintf(stderr, "[%s] %s\n", severity_str, msg);
	}
}
```

当发生严重错误的时候，`libevent`在完成日志记录后，会调用`event_exit`退出，退出处理函数也可以注册回调。

```cpp
void
event_set_fatal_callback(event_fatal_cb cb)
{
	fatal_fn = cb;
}

static void
event_exit(int errcode)
{
	if (fatal_fn) {
		fatal_fn(errcode);
		exit(errcode); /* should never be reached */
	} else if (errcode == EVENT_ERR_ABORT_)
		abort();
	else
		exit(errcode);
}
```

### 内存处理

定义在`mm_internal.h`，具体是实现取决于`_EVENT_DISABLE_MM_REPLACEMENT`宏定义，若未定义，则使用event内部实现，否则退化到标准库的内存分配函数。宏由编译参数`--disable-malloc-replacement`控制。

```cpp
#ifndef EVENT__DISABLE_MM_REPLACEMENT
/* Internal use only: Memory allocation functions. We give them nice short
 * mm_names for our own use, but make sure that the symbols have longer names
 * so they don't conflict with other libraries (like, say, libmm). */

... // 省略 event_mm_malloc_ 等函数声明

#define mm_malloc(sz) event_mm_malloc_(sz)
#define mm_calloc(count, size) event_mm_calloc_((count), (size))
#define mm_strdup(s) event_mm_strdup_(s)
#define mm_realloc(p, sz) event_mm_realloc_((p), (sz))
#define mm_free(p) event_mm_free_(p)
#else
#define mm_malloc(sz) malloc(sz)
#define mm_calloc(n, sz) calloc((n), (sz))
#define mm_strdup(s) strdup(s)
#define mm_realloc(p, sz) realloc((p), (sz))
#define mm_free(p) free(p)
#endif
```

`event_mm_malloc_`等函数的实现位于event.c文件，同时也支持用户注册回调。

```cpp
#ifndef EVENT__DISABLE_MM_REPLACEMENT
// 函数指针声明
static void *(*mm_malloc_fn_)(size_t sz) = NULL;
static void *(*mm_realloc_fn_)(void *p, size_t sz) = NULL;
static void (*mm_free_fn_)(void *p) = NULL;

// 实现
void *
event_mm_malloc_(size_t sz)
{
	if (sz == 0)
		return NULL;

	if (mm_malloc_fn_)
		return mm_malloc_fn_(sz);
	else
		return malloc(sz);
}

...

// 注册回调
void
event_set_mem_functions(void *(*malloc_fn)(size_t sz),
			void *(*realloc_fn)(void *ptr, size_t sz),
			void (*free_fn)(void *ptr))
{
	mm_malloc_fn_ = malloc_fn;
	mm_realloc_fn_ = realloc_fn;
	mm_free_fn_ = free_fn;
}
```

#### 注意事项

* 替换内存管理函数影响libevent 随后的所有分配、调整大小和释放内存操作。所以必须保证在调用任何其他libevent函数之前进行定制。否则，Libevent可能用定制的free函数释放C语言 库的malloc函数分配的内存
* malloc和realloc函数返回的内存块应该具有和C库返回的内存块一样的地址对齐
* realloc函数应该正确处理realloc(NULL, sz)（也就是当作malloc(sz)处理）
* realloc函数应该正确处理realloc(ptr, 0)（也就是当作free(ptr)处理）
* 如果在多个线程中使用libevent，替代的内存管理函数需要是线程安全的
* 如果要释放由Libevent函数分配的内存，并且已经定制了malloc和realloc函数，那么就应该使用定制的free函数释放。否则将会C语言标准库的free函数释放定制内存分配函数分配的内存，这将发生错误。所以三者要么全部不定制，要么全部定制。

### 多线程支持

`include/event2/thread.h`,`evthread-internal.h`,`evthread_pthread.c`,`evthread_win32.c`,`evthread.c`是多线程支持的相关实现。

`libevent`默认不开多线程功能。与内存管理的hook类似，所有线程相关的函数必须在event_base被创建之前注册。通过
`event_use_windows_threads()`或者`event_use_pthreads()`来注册使用`Windows threads`或者`Posix threads`。如果需要使用其他线程库，则需要`evthread_set_lock_callbacks()`和 `evthread_set_condition_callbacks()`来注册回调。

#### 锁结构

```cpp
/** This structure describes the interface a threading library uses for
 * locking.   It's used to tell evthread_set_lock_callbacks() how to use
 * locking on this platform.
 */
struct evthread_lock_callbacks {
	/** The current version of the locking API.  Set this to
	 * EVTHREAD_LOCK_API_VERSION */
	int lock_api_version;
	/** Which kinds of locks does this version of the locking API
	 * support?  A bitfield of EVTHREAD_LOCKTYPE_RECURSIVE and
	 * EVTHREAD_LOCKTYPE_READWRITE.
	 *
	 * (Note that RECURSIVE locks are currently mandatory, and
	 * READWRITE locks are not currently used.)
	 **/
	unsigned supported_locktypes;
	/** Function to allocate and initialize new lock of type 'locktype'.
	 * Returns NULL on failure. */
	void *(*alloc)(unsigned locktype);
	/** Funtion to release all storage held in 'lock', which was created
	 * with type 'locktype'. */
	void (*free)(void *lock, unsigned locktype);
	/** Acquire an already-allocated lock at 'lock' with mode 'mode'.
	 * Returns 0 on success, and nonzero on failure. */
	int (*lock)(unsigned mode, void *lock);
	/** Release a lock at 'lock' using mode 'mode'.  Returns 0 on success,
	 * and nonzero on failure. */
	int (*unlock)(unsigned mode, void *lock);
};
```

#### 锁类型

```cpp
/**
   @name Types of locks

   @{*/
/** A recursive lock is one that can be acquired multiple times at once by the
 * same thread.  No other process can allocate the lock until the thread that
 * has been holding it has unlocked it as many times as it locked it. */
#define EVTHREAD_LOCKTYPE_RECURSIVE 1
/* A read-write lock is one that allows multiple simultaneous readers, but
 * where any one writer excludes all other writers and readers. */
#define EVTHREAD_LOCKTYPE_READWRITE 2
/**@}*/
```

#### 锁模式

```cpp
/**
   @name Flags passed to lock functions

   @{
*/
/** A flag passed to a locking callback when the lock was allocated as a
 * read-write lock, and we want to acquire or release the lock for writing. */
#define EVTHREAD_WRITE	0x04
/** A flag passed to a locking callback when the lock was allocated as a
 * read-write lock, and we want to acquire or release the lock for reading. */
#define EVTHREAD_READ	0x08
/** A flag passed to a locking callback when we don't want to block waiting
 * for the lock; if we can't get the lock immediately, we will instead
 * return nonzero from the locking callback. */
#define EVTHREAD_TRY    0x10
/**@}*/
```

#### 多平台支持

Posix和Windows的支持分别有一个实现，具体见`evthread_pthread.c`,`evthread_win32.c`。

以Posix pthreads为例

```cpp
int
evthread_use_pthreads(void)
{
	struct evthread_lock_callbacks cbs = {
		EVTHREAD_LOCK_API_VERSION,
		EVTHREAD_LOCKTYPE_RECURSIVE,
		evthread_posix_lock_alloc,
		evthread_posix_lock_free,
		evthread_posix_lock,
		evthread_posix_unlock
	};
	struct evthread_condition_callbacks cond_cbs = {
		EVTHREAD_CONDITION_API_VERSION,
		evthread_posix_cond_alloc,
		evthread_posix_cond_free,
		evthread_posix_cond_signal,
		evthread_posix_cond_wait
	};
	/* Set ourselves up to get recursive locks. */
	if (pthread_mutexattr_init(&attr_recursive))
		return -1;
	if (pthread_mutexattr_settype(&attr_recursive, PTHREAD_MUTEX_RECURSIVE))
		return -1;

	evthread_set_lock_callbacks(&cbs);
	evthread_set_condition_callbacks(&cond_cbs);
	evthread_set_id_callback(evthread_posix_get_id);
	return 0;
}
```

#### 定制顺序

内存分配、日志记录、线程锁。这些定制都应该放在代码的最前面，即不能在使用 Libevent 的 event 、 event_base 这些结构体之后。因为这些结构体会使用到内存分配、日志记录、线程锁的。而这三者的定制顺序应该是：内存分配 -> 日志记录 -> 线程锁。

#### Debug支持

```cpp
/** Enable debugging wrappers around the current lock callbacks.  If Libevent
 * makes one of several common locking errors, exit with an assertion failure.
 *
 * If you're going to call this function, you must do so before any locks are
 * allocated.
 **/
EVENT2_EXPORT_SYMBOL
void evthread_enable_lock_debugging(void);
```

### 容器

`compat/sys/queue.h`

This file defines five types of data structures: singly-linked lists, lists, simple queues, tail queues, and circular queues.

#### tail queues

*定义*

```cpp
/*
 * Tail queue definitions.
 */
#define TAILQ_HEAD(name, type)						\
struct name {								\
	struct type *tqh_first;	/* first element */			\
	struct type **tqh_last;	/* addr of last next element */		\
}

#define TAILQ_HEAD_INITIALIZER(head)					\
	{ NULL, &(head).tqh_first }

#define TAILQ_ENTRY(type)						\
struct {								\
	struct type *tqe_next;	/* next element */			\
	struct type **tqe_prev;	/* address of previous next element */	\
}
```

除了这两个结构体，在queue.h文件中，还以宏定义的形式为TAILQ_QUEUE定义了一系列的访问和操作函数。

```cpp
//队列中的元素结构体。它有一个值，并且有前向指针和后向指针
//通过前后像指针，把队列中的节点(元素)连接起来
struct queue_entry_t
{
    int value;
 
    //从TAILQ_ENTRY的定义可知，它只能是结构体或者共用体的成员变量
    TAILQ_ENTRY(queue_entry_t)entry;
};
 
//定义一个结构体，结构体名为queue_head_t，成员变量类型为queue_entry_t
//就像有头节点的链表那样，这个是队列头。它有两个指针，分别指向队列的头和尾
TAILQ_HEAD(queue_head_t, queue_entry_t);
 
int main(int argc, char **argv)
{
    struct queue_head_t queue_head;
    struct queue_entry_t *q, *p, *s, *new_item;
    int i;
 
    TAILQ_INIT(&queue_head);
 
    for(i = 0; i < 3; ++i)
    {
        p = (struct queue_entry_t*)malloc(sizeof(struct queue_entry_t));
        p->value = i;
 
        //第三个参数entry的写法很怪，居然是一个成员变量名(field)
        TAILQ_INSERT_TAIL(&queue_head, p, entry);//在队尾插入数据
    }
 
    q = (struct queue_entry_t*)malloc(sizeof(struct queue_entry_t));
    q->value = 10;
    TAILQ_INSERT_HEAD(&queue_head, q, entry);//在队头插入数据
 
    //现在q指向队头元素、p指向队尾元素
 
    s = (struct queue_entry_t*)malloc(sizeof(struct queue_entry_t));
    s->value = 20;
    //在队头元素q的后面插入元素
    TAILQ_INSERT_AFTER(&queue_head, q, s, entry);
 
 
    s = (struct queue_entry_t*)malloc(sizeof(struct queue_entry_t));
    s->value = 30;
    //在队尾元素p的前面插入元素
    TAILQ_INSERT_BEFORE(p, s, entry);
 
    //现在进行输出
	//获取第一个元素
    s = TAILQ_FIRST(&queue_head);
    printf("the first entry is %d\n", s->value);
	
	//获取下一个元素
    s = TAILQ_NEXT(s, entry);
    printf("the second entry is %d\n\n", s->value);
 
    //删除第二个元素, 但并没有释放s指向元素的内存
    TAILQ_REMOVE(&queue_head, s, entry);
    free(s);
 
 
    new_item = (struct queue_entry_t*)malloc(sizeof(struct queue_entry_t));
    new_item->value = 100;
 
    s = TAILQ_FIRST(&queue_head);
    //用new_iten替换第一个元素
    TAILQ_REPLACE(&queue_head, s, new_item, entry);
 
 
    printf("now, print again\n");
    i = 0;
    TAILQ_FOREACH(p, &queue_head, entry)//用foreach遍历所有元素
    {
        printf("the %dth entry is %d\n", i, p->value);
    }
 
    p = TAILQ_LAST(&queue_head, queue_head_t);
    printf("last is %d\n", p->value);
 
    p = TAILQ_PREV(p, queue_head_t, entry);
    printf("the entry before last is %d\n", p->value);
}
```

gcc -E展开后

很精巧

![TAILQ内存结构](https://raw.githubusercontent.com/TDAkory/ImageResources/master/img/20220505114222.png)

```cpp
//p = TAILQ_LAST(&queue_head, queue_head_t);
p = (*(((struct queue_head_t *)((&queue_head)->tqh_last))->tqh_last));
```

```cpp
//p = TAILQ_PREV(p, queue_head_t, entry);
p = (*(((struct queue_head_t *)((p)->entry.tqe_prev))->tqh_last));
```