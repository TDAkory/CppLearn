# [libevent](https://libevent.org/)

- [libevent](#libevent)
  - [参考资料](#参考资料)
  - [源码分析笔记](#源码分析笔记)
    - [跨平台配置生成](#跨平台配置生成)
    - [日志支持](#日志支持)
    - [内存处理](#内存处理)
      - [注意事项](#注意事项)

## 参考资料

> [libevent深入浅出](https://github.com/aceld/libevent)
> [libevent源码深度剖析](https://github.com/luodw/Material/blob/master/libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90.pdf)

## 源码分析笔记

基于`release-2.1.12-stable`

### 跨平台配置生成

`event-config.h`

```cpp
/* event2/event-config.h
 *
 * This file was generated by autoconf when libevent was built, and post-
 * processed by Libevent so that its macros would have a uniform prefix.
 *
 * DO NOT EDIT THIS FILE.
 *
 * Do not rely on macros in this file existing in later versions.
 */
#ifndef EVENT_CONFIG_H__
#define EVENT_CONFIG_H__
/* config.h.  Generated by configure.  */
/* config.h.in.  Generated from configure.in by autoheader.  */
```

`event-config.h`这个文件并不是一直不变的，这里有一个过程：

* 首先，configure在检查环境依赖的时候会生成config.h和Makefile;
* 然后，Makefile会根据config.h生成event-config.h;

文件中的宏定义，对代码运行环境进行了详细的检查，包括是否包含特定的头文件，libc库是否包含特定的函数，是否声明了某些特定名字的结构体，支持哪些IO多路复用机制等等，举例：

```cpp
/* Define to 1 if you have the <dlfcn.h> header file. */
#define EVENT__HAVE_DLFCN_H 1
/* Define if your system supports the epoll system calls */
#define EVENT__HAVE_EPOLL 1
/* Define to 1 if you have the `epoll_create1' function. */
/* #undef EVENT__HAVE_EPOLL_CREATE1 */
/* Define to 1 if you have the `epoll_ctl' function. */
#define EVENT__HAVE_EPOLL_CTL 1
/* Define to 1 if you have the <errno.h> header file. */
#define EVENT__HAVE_ERRNO_H 1
```

### 日志支持

主要实现在`log.c`文件中。默认行为是输出到控制台，同时支持用户设置日志回调`event_set_log_callback`;

内部使用的日志接口定义在`log-internal.h`;

```cpp
/**
  A callback function used to intercept Libevent's log messages.

  @see event_set_log_callback
 */
typedef void (*event_log_cb)(int severity, const char *msg);


static event_log_cb log_fn = NULL;

void
event_set_log_callback(event_log_cb cb)
{
	log_fn = cb;
}

static void
event_log(int severity, const char *msg)
{
	if (log_fn)
		log_fn(severity, msg);
	else {
		const char *severity_str;
		switch (severity) {
		... // different severity
		}
        // output to console
		(void)fprintf(stderr, "[%s] %s\n", severity_str, msg);
	}
}
```

当发生严重错误的时候，`libevent`在完成日志记录后，会调用`event_exit`退出，退出处理函数也可以注册回调。

```cpp
void
event_set_fatal_callback(event_fatal_cb cb)
{
	fatal_fn = cb;
}

static void
event_exit(int errcode)
{
	if (fatal_fn) {
		fatal_fn(errcode);
		exit(errcode); /* should never be reached */
	} else if (errcode == EVENT_ERR_ABORT_)
		abort();
	else
		exit(errcode);
}
```

### 内存处理

定义在`mm_internal.h`，具体是实现取决于`_EVENT_DISABLE_MM_REPLACEMENT`宏定义，若未定义，则使用event内部实现，否则退化到标准库的内存分配函数。宏由编译参数`--disable-malloc-replacement`控制。

```cpp
#ifndef EVENT__DISABLE_MM_REPLACEMENT
/* Internal use only: Memory allocation functions. We give them nice short
 * mm_names for our own use, but make sure that the symbols have longer names
 * so they don't conflict with other libraries (like, say, libmm). */

... // 省略 event_mm_malloc_ 等函数声明

#define mm_malloc(sz) event_mm_malloc_(sz)
#define mm_calloc(count, size) event_mm_calloc_((count), (size))
#define mm_strdup(s) event_mm_strdup_(s)
#define mm_realloc(p, sz) event_mm_realloc_((p), (sz))
#define mm_free(p) event_mm_free_(p)
#else
#define mm_malloc(sz) malloc(sz)
#define mm_calloc(n, sz) calloc((n), (sz))
#define mm_strdup(s) strdup(s)
#define mm_realloc(p, sz) realloc((p), (sz))
#define mm_free(p) free(p)
#endif
```

`event_mm_malloc_`等函数的实现位于event.c文件，同时也支持用户注册回调。

```cpp
#ifndef EVENT__DISABLE_MM_REPLACEMENT
// 函数指针声明
static void *(*mm_malloc_fn_)(size_t sz) = NULL;
static void *(*mm_realloc_fn_)(void *p, size_t sz) = NULL;
static void (*mm_free_fn_)(void *p) = NULL;

// 实现
void *
event_mm_malloc_(size_t sz)
{
	if (sz == 0)
		return NULL;

	if (mm_malloc_fn_)
		return mm_malloc_fn_(sz);
	else
		return malloc(sz);
}

...

// 注册回调
void
event_set_mem_functions(void *(*malloc_fn)(size_t sz),
			void *(*realloc_fn)(void *ptr, size_t sz),
			void (*free_fn)(void *ptr))
{
	mm_malloc_fn_ = malloc_fn;
	mm_realloc_fn_ = realloc_fn;
	mm_free_fn_ = free_fn;
}
```

#### 注意事项

* 替换内存管理函数影响libevent 随后的所有分配、调整大小和释放内存操作。所以必须保证在调用任何其他libevent函数之前进行定制。否则，Libevent可能用定制的free函数释放C语言 库的malloc函数分配的内存
* malloc和realloc函数返回的内存块应该具有和C库返回的内存块一样的地址对齐
* realloc函数应该正确处理realloc(NULL, sz)（也就是当作malloc(sz)处理）
* realloc函数应该正确处理realloc(ptr, 0)（也就是当作free(ptr)处理）
* 如果在多个线程中使用libevent，替代的内存管理函数需要是线程安全的
* 如果要释放由Libevent函数分配的内存，并且已经定制了malloc和realloc函数，那么就应该使用定制的free函数释放。否则将会C语言标准库的free函数释放定制内存分配函数分配的内存，这将发生错误。所以三者要么全部不定制，要么全部定制。
